# -*- coding: utf-8-unix -*-
#+PROPERTY: header-args:emacs-lisp :tangle tangle/emacs-10-init.el :results silent :noweb yes
* Contents :QUOTE:TOC_2_gh:
#+BEGIN_QUOTE
- [[#overview][Overview]]
  - [[#about-this-document][About this document]]
- [[#base-settings][Base settings]]
  - [[#meta-packages][Meta packages]]
  - [[#gui-interface][GUI Interface]]
  - [[#devices][Devices]]
  - [[#server][Server]]
  - [[#exwm][Exwm]]
  - [[#font][Font]]
  - [[#theme--faces][Theme & Faces]]
  - [[#user-info][User info]]
  - [[#garbage-collection][Garbage collection]]
  - [[#desktop-module][Desktop module]]
  - [[#customize][Customize]]
  - [[#file-and-input-history][File and input history]]
  - [[#local-variables][Local variables]]
  - [[#personal-keymap][Personal keymap]]
  - [[#base-commands-simpleel][Base commands (simple.el)]]
- [[#selection-and-search-methods][Selection and search methods]]
  - [[#completion-frameworks][Completion frameworks]]
  - [[#isearch-enhancements][isearch enhancements]]
- [[#directory-project-buffer-window-management][Directory, project, buffer, window management]]
  - [[#dired][Dired]]
  - [[#tramp][Tramp]]
  - [[#git][Git]]
  - [[#projects][Projects]]
  - [[#working-with-buffers][Working with buffers]]
  - [[#window-configuration][Window configuration]]
  - [[#file-encryption][File encryption]]
- [[#applications-and-utilities][Applications and utilities]]
  - [[#calendar][Calendar]]
  - [[#pdfs][PDFs]]
  - [[#latex][Latex]]
  - [[#programming-languages][Programming languages]]
  - [[#cad][CAD]]
  - [[#calc][Calc]]
  - [[#org-mode][Org mode]]
  - [[#deft][Deft]]
  - [[#shell][Shell]]
  - [[#grep][Grep]]
  - [[#proced][Proced]]
  - [[#passwords][Passwords]]
  - [[#ledger][Ledger]]
  - [[#plotting-data][Plotting data]]
  - [[#html-renderer][HTML renderer]]
  - [[#email][Email]]
  - [[#footnote-mode][Footnote Mode]]
  - [[#bbdb][BBDB]]
  - [[#compile][Compile]]
  - [[#speed-reading][Speed reading]]
  - [[#context-aware-hydra][Context aware hydra]]
  - [[#ssh-tunnels][SSH tunnels]]
  - [[#minor-utilities][Minor utilities]]
- [[#language-settings][Language settings]]
  - [[#spellcheck][Spellcheck]]
- [[#interface][Interface]]
  - [[#general][General]]
  - [[#rainbow-mode][Rainbow mode]]
  - [[#parentheses][Parentheses]]
  - [[#whitespace][Whitespace]]
  - [[#notifications][Notifications]]
  - [[#undo][Undo]]
  - [[#electric-stuff][Electric stuff]]
  - [[#writing-setup][Writing Setup]]
- [[#wrapping-up][Wrapping up]]
#+END_QUOTE

* Overview
** About this document
This files contains all the elisp code normally placed in the .emacs
file. It and the =init.el= file are then symlinked to my =~/.emacs.d/=
directory. Instead of symlinking the files could also be directly
tangled to =~/.emacs.d/=.
#+BEGIN_SRC shell :results silent :tangle tangle/symlink.sh :shebang "#!/bin/bash" :noweb yes
ln -siv $(pwd)/emacs-init.org ~/.emacs.d/
ln -siv $(pwd)/tangle/init.el ~/.emacs.d/
ln -siv $(pwd)/tangle/emacs-10-init.el ~/.emacs.d/
ln -siv $(pwd)/tangle/init-exwm.el ~/.emacs.d/
ls emacs-*.el.gpg | xargs -I FILE ln -siv $(pwd)/FILE ~/.emacs.d
<<symlinks>>
#+END_SRC

An often seen setup is to use ~org-babel-load-file~ in =init.el= to
load this =.org= configuration file. Instead I chose to auto-tangle
the =.org= file on every save and load the tangled =.el= file
directly. This saves time on startup as tangling does not occur
everytime and also allows for more flexibility regarding tangling file
locations in this configuration file. Namely I can include the content
of =init.el= in this file without problems.

To share this configuration publicly, even though it contains private
information, several solutions are possible. To keep everything in one
file, [[elisp:(find-library "org-crypt")][org-crypt]] is a possible solution. Marking the headings with
private information with the tag =:crypt:= and adding the following to
=init.el= works as a basic setup for =org-crypt=. Also make sure to
disable ~buffer-auto-save-file-name~ for the files.
#+BEGIN_SRC emacs-lisp :noweb-ref org-crypt :tangle no
(use-package org-crypt
  :config (org-crypt-use-before-save-magic)
  :custom
  (org-crypt-key "F1EF502F9E81D81381B1679AF973BBEA6994521B"))
#+END_SRC

#+BEGIN_SRC emacs-lisp :noweb-ref org-custom-no-inheritance-tags :tangle no
"crypt"
#+END_SRC

I use =.org= configuration files also for my other dotfiles. To ensure
they are tangled upon save I use this function.
#+NAME: tangle-hook
#+BEGIN_SRC emacs-lisp :tangle no
(defun fpi/tangle-dotfiles ()
  "If the current file is in '~/.dotfiles' tangle all code blocks."
  (when (equal (file-name-directory (directory-file-name buffer-file-name))
               (expand-file-name "git/projects/dotfiles/" (getenv "HOME")))
    (org-babel-tangle)
    (message "%s tangled" buffer-file-name)))
(defmacro fpi/tangle-async (&optional file)
  "Tangle FILE with a separate emacs instance.

Note that this does not respect any customization of the tangle
process in your init file as it is not loaded. This uses the
emacs-async library."
  (interactive)
  (let ((file (or file (buffer-file-name))))
    (and file
         (not (file-remote-p file))
         `(async-start
           (lambda ()
             (require 'org)
             (require 'org-clock)
             (org-babel-tangle-file ,file)
             (org-notify (format "Tangled %s" ,file))
             'ignore)))))
#+END_SRC
As I use =org-crypt= all =.org= files need to be decrypted before
tangling, saved without encrypting and encrypted after tangling and
saved again. The latter part is not directly supported by =org=.
~org-babel-post-tangle-hook~ is executed in the created tangled files
and not inside the source =.org= file. Instead I add an advice to
~org-babel-tangle~.
#+NAME: org-crypt-tangle-setup
#+BEGIN_SRC emacs-lisp :tangle no
(defun save-without-hook ()
  (let ((before-save-hook nil))
    (save-buffer)))

(setq org-babel-pre-tangle-hook '(org-decrypt-entries save-without-hook))
;; (setq org-babel-post-tangle-hook '(org-encrypt-entries save-without-hook))
(advice-add 'org-babel-tangle :after '(lambda (&rest r)
                                        (org-encrypt-entries)
                                        (save-without-hook)))
#+END_SRC

Using =org-crypt= unfortunately leads to unusable diffs in =git= for
the encrypted parts. So I tend to only use it for configuration files
which I do not want to split into multiple files. The approach of
using a separate =.el.gpg= or =.org.gpg= file has the same problem.
But =git= can be told to decrypt =.gpg= files before creating the diff
using the following settings (see [[https://magit.vc/manual/magit/How-to-show-diffs-for-gpg_002dencrypted-files_003f.html][here]]).
#+begin_src shell
git config --global diff.gpg.textconv "gpg --no-tty --decrypt"
echo "*.gpg filter=gpg diff=gpg" > .gitattributes
#+end_src
A similar behaviour can be achieved using [[https://github.com/AGWA/git-crypt][git-crypt]]. I save private
details regarding my emacs configuration in =.el.gpg= files and
load them in =init.el= using some code like this.
#+begin_src emacs-lisp :tangle no
(mapc (lambda (file) (load file))
      (directory-files default-directory t "^emacs-.*el.gpg$"))
#+end_src

This is the content of =init.el=. Notice the ~:tangle tangle/init.el~
header argument in the source code.
#+begin_src emacs-lisp :tangle tangle/init.el
<<straight.el>>

;; package.el to enable use of list-packages
<<package.el>>

(setq vc-follow-symlinks t)

;; For use on Windows via SSH X-Forwarding
;; See https://emacs.stackexchange.com/a/42440/25850
(setq default-frame-alist
         (append default-frame-alist '((inhibit-double-buffering . t))))
(setq posframe-inhibit-double-buffering t)

(mapc (lambda (file) (load file))
      (directory-files user-emacs-directory t "^emacs-.*el\\(.gpg\\)\\{0,1\\}"))
#+end_src

I always wanted to reorganize my old init file with >5000 lines, but
never managed to do it completely. So I decided to start from scratch.
The structure and some of the base content is loosely based on the
[[https://gitlab.com/protesilaos/dotemacs/][config of Protesilaos Stavrou]]. Several functions and definitions are
from other configs as well. They are mentioned in the appropriate
places.

Notable configs:
- [[https://gitlab.com/protesilaos/dotemacs/][Protesilaos Stavrou]]
- [[http://doc.rix.si/cce/cce.html][Ryan Rix]]
- [[http://doc.norang.ca/org-mode.html][Bernt Hansen]]

* Base settings
** Meta packages
Packages that don't do anything by themselves, but can be used to help
with other package definition and customization.
*** package.el
=package.el= setup. While I switched to [[id:eef88cd4-f2f5-4e4b-b7bb-75faac36dcb8][straight.el]], I keep =package.el= loaded for now to be able to browse ELPA/MELPA with ~M-x list-packages~.
#+BEGIN_SRC emacs-lisp :noweb-ref package.el :tangle no
(require 'package)
;; (package-initialize)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
(add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") nil)
(package-refresh-contents t)
#+END_SRC
*** straight.el
:PROPERTIES:
:ID:       eef88cd4-f2f5-4e4b-b7bb-75faac36dcb8
:END:
[[https://github.com/raxod502/straight.el][straight.el]] is a package manager for emacs, which in contrast to =package.el= keeps track of the current package versions and supports local development on packages. See the [[https://github.com/raxod502/straight.el#comparison-to-other-package-managers][github page]] for a detailed comparison with other package managers.
#+begin_src emacs-lisp :noweb-ref straight.el :tangle no
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
#+end_src

#+BEGIN_SRC emacs-lisp
(setq straight-profiles `((nil . ,(expand-file-name "package-versions.el" "~/git/projects/dotfiles"))))
(setq straight-recipe-overrides
      '(nil . (
               <<straight-recipe-overrides>>
               )))
#+END_SRC
**** straight.el documentation excerpts
:PROPERTIES:
:header-args:emacs-lisp: :tangle no
:END:
***** General usage
#+begin_quote
- To restore each package to its canonical state (a clean working
  directory with the main branch checked out, and the remotes set
  correctly), run ~M-x straight-normalize-package~ or ~M-x
  straight-normalize-all~.
- To fetch from each package's configured remote, run ~M-x
  straight-fetch-package-and-deps~ or ~M-x straight-fetch-all~; to
  also fetch from the upstream for forked packages, supply a prefix
  argument.
- To merge changes from each package's configured remote, run ~M-x
  straight-merge-package-and-deps~ or ~M-x straight-merge-all~; to
  also merge from the upstream for forked packages, supply a prefix
  argument.
- To push all local changes to each package's configured remote, run
  ~M-x straight-push-package~ or ~M-x straight-push-all~.
#+end_quote
***** Freezing package versions
#+begin_quote
To save the currently checked out revisions of all of your packages,
run ~M-x straight-freeze-versions~. The resulting file
(~~/.emacs.d/straight/versions/default.el~), together with your
init-file, perfectly define your package configuration. Keep your
version lockfile checked into version control; when you install your
Emacs configuration on another machine, the versions of packages
specified in your lockfile will automatically be checked out after the
packages are installed. You can manually revert all packages to the
revisions specified in the lockfile by running ~M-x
straight-thaw-versions~.
#+end_quote
***** =use-package= integration
#+begin_src emacs-lisp
(use-package el-patch
  :straight (:host github :repo "raxod502/el-patch"
                   :branch "develop"))
(use-package tex-site
  :straight (auctex :host github
                    :repo "emacsmirror/auctex"
                    :files (:defaults (:exclude "*.el.in"))))
#+end_src
*** Use-package
#+begin_src emacs-lisp
(straight-use-package 'use-package)
#+end_src
*** Hydra
#+begin_src emacs-lisp
(use-package hydra
  :straight t)
#+end_src
This package allows hydra definitions in use-package.
#+begin_src emacs-lisp
(use-package use-package-hydra
  :straight t)
#+end_src
*** which-key
In Emacs you can press =?= or =C-h= after starting a key combination
to get a list of available commands. =which-key= shows these in a
small popup, which I think is more handy.
#+begin_src emacs-lisp
(use-package which-key
  :straight t
  :custom
  (which-key-idle-delay 0.4)
  (which-key-lighter "")
  :config (which-key-mode 1))
#+end_src
*** Try
Sometimes I stumble over a package and want to try it out without
commiting to it and installing it fully â€“ possibly forgetting to
remove it. =Try= installs packages temporarily for this emacs session
only.
#+begin_src emacs-lisp
(use-package try
  :straight t)
#+end_src
** GUI Interface
Disable most of the user interface.
#+BEGIN_SRC emacs-lisp
(use-package emacs
  :custom
  <<emacs-custom>>
  :config
  (tooltip-mode -1)
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
  )
#+END_SRC

Audible bell is useless when the sound is turned off and annoying when sound is on. Instead use visible bell.
#+begin_src emacs-lisp :tangle no :noweb-ref emacs-custom
(visible-bell t)
#+end_src

In /awesomewm/ and other tiling window managers the emacs window
leaves a gap at the bottom. This removes it.
#+BEGIN_SRC emacs-lisp
(setq frame-resize-pixelwise t)
#+END_SRC
*** Mode Line & Header Line
=header-info= is an easy way to move part of the mode line information to the header line instead.

#+begin_src emacs-lisp
(use-package header-info
  :straight (:host github :repo "fpiper/header-info"
                   :branch "master"))
#+end_src
**** Remove mode line clutter
#+begin_src emacs-lisp
(use-package delight
  :straight t
  :after use-package)
#+end_src
If removing mode symbols with =delight= is not enough, the mode line
can also be completely removed by setting ~mode-line-format~ to ~nil~.
=hide-mode-line= is a small minor mode that can toggle the mode-line
on and off. I added ~redraw-display~, because i had problems with the
mode-line not being redisplayed, when turning the mode off even though
it calls ~force-mode-line-update~.
#+begin_src emacs-lisp
(use-package hide-mode-line
  :straight t
  :hook
  (hide-mode-line-mode . redraw-display)
  (help-mode . hide-mode-line-mode))
(global-set-key (kbd "C-c m") 'hide-mode-line-mode)
#+end_src
** Devices
To support different settings on different devices storing some device information seems useful.
#+begin_src emacs-lisp
(setq fpi/current-device (system-name))
(setq fpi/devices
      '(("peter"
         (:type desktop
                :os win10))
        ("pan"
         (:type desktop
                :wm exwm))
        ("xcarb"
         (:type mobile))
        ("DESKTOP-PM1PPEC"
         (:type mobile
                :os win10))
        ))
(defun fpi/device-info (device prop)
  "Return property PROP of DEVICE as stored in `fpi/devices'."
  (let ((info (cadr (assoc device fpi/devices))))
    (plist-get info prop)))
(defun fpi/current-device-info (prop)
  "Return property PROP of current device."
  (let ((info (cadr (assoc fpi/current-device fpi/devices))))
    (plist-get info prop)))
#+end_src
Now we can easily extract info on the current device.
#+begin_src emacs-lisp :tangle no :exports both :results replace
(fpi/device-info "pan" :type)
#+end_src

#+RESULTS:
: desktop
** Server
#+begin_src emacs-lisp :tangle no
(use-package server
  :config
  (unless (server-running-p) (server-start)))
#+end_src
** Exwm
The previous sections cover all basic settings which may be useful when loading =exwm=.
My =exwm= configurations are in [[file:init-exwm.org][init-exwm.org]] and we can load the tangled version here. In the future I may convert it into a standalone package.
#+begin_src emacs-lisp
(when (and (equal (getenv "DESKTOP_SESSION") "exwm")
           (eq window-system 'x))
  (load (concat user-emacs-directory "init-exwm.el"))
#+end_src
Also enable =exwm=. This does nothing if =emacs= is not started as window manager.
#+begin_src emacs-lisp
  (exwm-enable))
#+end_src
** Font
I am still not quite sure on my choice of font.

=fpi/set-font= is a safe way to choose a font based on
availability. When starting with =emacs --daemon= it does not work as
=(font-family-list)= won't return anything.
#+begin_src emacs-lisp :tangle no
(use-package emacs
  :config
  (defun fpi/set-font ()
    (interactive)
    (cond
     ((member "Hack" (font-family-list)e)
      (add-to-list 'default-frame-alist '(font . "Hack-12")))
     ((member "Source Code Pro" (font-family-list))
      (add-to-list 'default-frame-alist '(font . "Source Code Pro-12")))))
    (add-to-list 'default-frame-alist '(font . "Hack-12"))
  ;; :hook (after-init . fpi/set-font)
  )
#+end_src

Instead of the above code I set the font directly using
=set-face-attribute=. This is overwritten by my theme settings.
#+begin_src emacs-lisp
(set-face-attribute 'default nil :font "Hack-11")
#+end_src

#+begin_src emacs-lisp
(use-package emacs
  :commands (prot/font-set-face-attribute
             prot/font-set-fonts
             prot/font-set-font-size-family
             prot/font-fonts-dwim)
  :config
  (setq x-underline-at-descent-line t)
  (setq underline-minimum-offset 1)

  (defconst prot/font-fontconfig-params
    "embeddedbitmap=false:autohint=false:hintstyle=hintslight"
    "Additional parameters for the given font family.
These are specific to the fontconfig backend for GNU/Linux systems.")

  (defvar prot/font-set-fonts-hook nil
    "Hook that is called after setting fonts.
See, for example, `prot/font-set-fonts'.")

  ;; The idea with this association list is to use font combinations
  ;; that are suitable to the given point size and intended function.
  ;; Basically, I have three modes: my laptop's small screen, my laptop
  ;; attached to a larger external monitor in a desktop setup (my normal
  ;; case), and when I do presentations (i.e. my videos on Emacs).
  ;;
  ;; I find that at smaller sizes the open and wide proportions of
  ;; Hack+FiraGO combined with their more intense typographic colour
  ;; work best, while the more compact Iosevka+Source Sans Pro are
  ;; better at larger point sizes.  The "desktop" combo is ideal for use
  ;; on a larger monitor at a regular point size.  The latter is what I
  ;; typically use to write prose or code.
  ;;
  ;; Note that the "Hack" typeface mentioned here is my patched version
  ;; of it, which uses some alternative glyphs, is built on top of the
  ;; latest dev branch, and is meant to improve both the Roman and
  ;; Italic variants (alt glyphs are part of the Hack project):
  ;; https://gitlab.com/protesilaos/hackfontmod
  (defconst prot/font-sizes-families-alist
    '(("laptop" . (10.5 "Hack" "Source Sans Pro" 1))
      ("desktop" . (13 "Hack" "Alegreya" 4))
      ("presentation" . (19 "Iosevka SS08" "Source Sans Pro" 1)))
    "Alist of desired point sizes and their typefaces.
Each association consists of a display type mapped to a point
size, followed by monospaced and proportionately-spaced font
names, and a difference in desired size between the latter two to
account for their innate differences in proportions (this number
represents pixels and is found empirically).

The monospaced typeface is meant to be applied to the `default'
and `fixed-pitch' faces.  The proportionately-space font is
intended for the `variable-pitch' face.")

  (defun prot/font-set-face-attribute (face family size &optional params)
    "Set FACE font to FAMILY at SIZE with optional PARAMS."
    (let ((params (if params
                      params
                    prot/font-fontconfig-params)))
      (set-face-attribute
       `,face nil :font
       (format "%s-%s:%s" family (number-to-string size) params))))





  (defun prot/font-set-fonts (&optional points font-mono font-var)
    "Set default font size using presets.

POINTS is the font's point size, represented as either '10' or
'10.5'.  FONT-MONO should be a monospaced typeface, due to the
alignment requirements of the `fixed-pitch' face.  FONT-VAR could
be a proportionately-spaced typeface or even a monospaced one,
since the `variable-pitch' it applies to is not supposed to be
spacing-sensitive.  Both families must be represented as a string
holding the family's name."
    (interactive)
    (let* ((data prot/font-sizes-families-alist)
           (displays (mapcar #'car data))
           (choice (if points
                       points
                     (completing-read "Pick display size: " displays nil t)))
           (size (if points
                     points
                   (nth 1 (assoc `,choice data))))
           (mono (if font-mono
                     font-mono
                   (if (member choice displays)
                       (nth 2 (assoc `,choice data))
                     nil)))
           (var (if font-var
                    font-var
                  (if (member choice displays)
                      (nth 3 (assoc `,choice data))
                    nil)))
           (adjust (nth 4 (assoc `,choice data))))
      (when window-system
        (dolist (face '(default fixed-pitch))
          (prot/font-set-face-attribute `,face mono size))
        (prot/font-set-face-attribute 'variable-pitch var (+ size adjust))))
    (run-hooks 'prot/font-switch-fonts-hook))

  (defvar prot/font-monospaced-fonts-list
    '("Hack" "Iosevka SS08" "Iosevka Slab" "Source Code Pro"
      "Ubuntu Mono" "Fantasque Sans Mono" "DejaVu Sans Mono"
      "Fira Code" "Victor Mono" "Roboto Mono")
    "List of typefaces for coding.
See `prot/font-set-font-size-family' for how this is used.")

  (defun prot/font-set-font-size-family ()
    "Set point size and main typeface.
This command is intended for testing various font families at
some common point sizes.

See `prot/font-set-fonts' for the function I would normally use
or `prot/font-fonts-dwim' which just wraps this one with that."
    (interactive)
    (let* ((fonts prot/font-monospaced-fonts-list)
           (font (completing-read "Select main font: " fonts nil t))
           (nums (list 13 14 15 16))
           (sizes (mapcar 'number-to-string nums))
           (size (completing-read "Select or insert number: " sizes nil))
           (var (face-attribute 'variable-pitch :family)))
      (dolist (face '(default fixed-pitch))
        (prot/font-set-face-attribute face font (string-to-number size)))
      (prot/font-set-face-attribute 'variable-pitch var (string-to-number size))
      (run-hooks 'prot/font-switch-fonts-hook)))

  (defun prot/font-fonts-dwim (&optional arg)
    "Set fonts interactively.
This is just a wrapper around `prot/font-set-fonts' and
`prot/font-set-font-size-family', whose sole purpose is to
economise on dedicated key bindings."
    (interactive "P")
    (if arg
        (prot/font-set-font-size-family)
      (prot/font-set-fonts)))

  (defvar prot/font-fonts-line-spacing-alist
    '(("Iosevka SS08" . 1)
      ("Iosevka Slab" . 1)
      ("Source Code Pro" . 1)
      ("Ubuntu Mono" . 2))
    "Font families in need of extra `line-spacing'.
See `prot/font-line-spacing' for how this is used.")

  (defvar prot/font-fonts-bold-weight-alist
    '(("Source Code Pro" . semibold))
    "Font families in need of a variegated weight for `bold'.
See `prot/font-bold-face' for how this is used.")

  (defmacro prot/font-adjustment (fn doc alist cond1 cond2)
    "Macro for functions that employ `prot/font-switch-fonts-hook'.
NAME is the name of the resulting function.  DOC is its
docstring.  ALIST is an assosiation list of cons cells.  COND1
and COND2 is the body of an `if' statement's 'if' and 'then' part
respectively."
    `(defun ,fn ()
       ,doc
       (let* ((data ,alist)
              (fonts (mapcar #'car data))
              ;; REVIEW This should be adjusted to account for the
              ;; possibility of a distinct font family for the `bold'
              ;; face.
              (font (face-attribute 'default :family))
              (x (cdr (assoc font data))))
         (if (member font fonts)
             ,cond1
           ,cond2))))

  (prot/font-adjustment
   prot/font-line-spacing
   "Determine desirable `line-spacing', based on font family."
   prot/font-fonts-line-spacing-alist
   (setq-default line-spacing `,x)
   (setq-default line-spacing nil))

  ;; XXX This will not work with every theme, but only those that
  ;; inherit the `bold' face instead of specifying a weight property.
  ;; The intent is to configure this once and have it propagate wherever
  ;; a heavier weight is displayed.  My Modus themes handle this
  ;; properly.
  (prot/font-adjustment
   prot/font-bold-face
   "Determine weight for the `bold' face, based on font family."
   prot/font-fonts-bold-weight-alist
   (set-face-attribute 'bold nil :weight `,x)
   (set-face-attribute 'bold nil :weight 'bold))

  (defun prot/font-fonts-per-monitor ()
    "Use font settings based on screen size.
Meant to be used at some early initialisation stage, such as with
`after-init-hook'."
    (let* ((display (if (<= (display-pixel-width) 1366)
                        "laptop"
                      "desktop"))
           (data prot/font-sizes-families-alist)
           (size (cadr (assoc `,display data)))
           (mono (nth 2 (assoc `,display data)))
           (var (nth 3 (assoc `,display data)))
           (adjust (nth 4 (assoc `,display data))))
      (dolist (face '(default fixed-pitch))
        (prot/font-set-face-attribute face mono size))
      (prot/font-set-face-attribute 'variable-pitch var (+ size adjust))
      (run-hooks 'prot/font-switch-fonts-hook)))

  :hook ((after-init-hook . prot/font-fonts-per-monitor)
         (prot/font-set-fonts-hook . prot/font-line-spacing)
         (prot/font-set-fonts-hook . prot/font-bold-face))
  ;; Awkward key because I do not need it very often.  Maybe once a day.
  ;; The "C-c f" is used elsewhere.
  :bind ("C-c F" . prot/font-fonts-dwim))
#+end_src
*** Emoji
For undefined characters in the default font, we can set a fallback font using [[info:emacs#Fontsets][fontsets]].

Here we set it to use the google icons as fallback.
#+begin_src emacs-lisp
(set-fontset-font "fontset-default" 'unicode "Noto Color Emoji")
#+end_src
Alternatively we could use =OpenMoji= or other icon sets.
#+begin_src emacs-lisp :tangle no
(set-fontset-font "fontset-default" 'unicode "OpenMoji")
#+end_src
** Theme & Faces
=hc-zenburn= is the theme I chose for a long time. Lately I started to
appreciate light themes more. [[https://gitlab.com/protesilaos/modus-themes][modus-operandi]] is an interesting light
theme promising high color contrast. I ended up using the
=spacemacs-light= and =spacemacs-dark= themes.

This is written here for clarity, but only executed at the end of my
init files, after some variables which depend on the current theme are
defined, for example ~pdf-view-midnight-colors~.
#+NAME: themes
#+begin_src emacs-lisp :tangle no
<<theme-functions>>
(defcustom fpi/light-theme-list '(spacemacs-light spacemacs-light-customizations)
  "List of themes to activate when using a light theme.")
(defcustom fpi/dark-theme-list '(spacemacs-dark spacemacs-dark-customizations)
  "List of themes to activate when using a dark theme.")
(defcustom fpi/current-theme 'light
  "Currently activated theme variation.")

(fpi/load-themes)
#+end_src

Functions to load themes based on the ~fpi/current-theme~ setting and to toggle the current theme between light and dark.
#+begin_src emacs-lisp :noweb-ref theme-functions :tangle no
(defun fpi/load-themes (&optional theme-variation)
  "Load themes based on the value of `fpi/current-theme'.

Optionally provide THEME-VARIATION to override
`fpi/current-theme'. Loaded themes are based on the value
of `(format \"fpi/%s-theme-list\" fpi/current-theme)'"
  (interactive)
  (mapc 'disable-theme custom-enabled-themes);; disable all themes
  (let* ((theme-variation (or theme-variation fpi/current-theme))
         (themes (eval (intern (format "fpi/%s-theme-list" theme-variation)))))
    (mapc (lambda (theme) (load-theme theme t)) themes)))
(defun fpi/toggle-theme ()
  "Toggle between light and dark theme."
  (interactive)
  (if (eq fpi/current-theme 'light)
      (progn
        (customize-save-variable 'fpi/current-theme 'dark)
        (fpi/load-themes))
    (customize-save-variable 'fpi/current-theme 'light)
    (fpi/load-themes)))
#+end_src
#+begin_src emacs-lisp :tangle no :noweb-ref fpi-bindings
(define-key fpi/toggle-map "dt" #'fpi/toggle-theme)
#+end_src
*** Getting themes
#+begin_src emacs-lisp
(use-package spacemacs-light-theme
  :no-require t
  :straight (spacemacs-theme))
(use-package spacemacs-dark-theme
  :no-require t
  :straight (spacemacs-theme))
#+end_src

#+begin_src emacs-lisp :tangle no
(use-package modus-operandi-theme
  :straight t)
(use-package modus-vivendi-theme
  :straight t)
#+end_src
*** Theme customization
In this section is code to produce a custom theme out of a list of predefined colors and custom face specs.

First a function to replace colors in the face specs.
#+begin_src emacs-lisp
(defun prep-custom-theme-set-faces (colors faces-alist)
  (defmacro get-proper-faces ()
    `(let* (,@colors)
       (backquote ,faces-alist)))
  (get-proper-faces))
#+end_src

This call now creates a custom theme based on the settings in the sections
[[id:82021d54-89d6-4712-8e5a-df2fc6177c96][Colors]] and [[id:a3b74d3b-675e-426d-b675-e70dcfd3d2b6][Faces]]. These are my customizations to the spacemacs theme. Make sure to manually run these customization blocks after changing a face, as only the result blocks are tangled!
#+begin_src emacs-lisp :tangle no :results code replace  :wrap "src emacs-lisp :tangle tangle/spacemacs-dark-customizations-theme.el" :exports both
`(progn
   (deftheme spacemacs-dark-customizations
     "My customizations to spacemacs-dark (Created 2020-06-27)")
   (custom-theme-set-faces
    'spacemacs-dark-customizations
    ,@(prep-custom-theme-set-faces
       (quote
        <<colors>>)
       <<faces-spacemacs-dark>>))
    (provide-theme 'spacemacs-dark-customizations))
#+end_src

#+RESULTS:
#+begin_src emacs-lisp :tangle tangle/spacemacs-dark-customizations-theme.el
(progn
  (deftheme spacemacs-dark-customizations "My customizations to spacemacs-dark (Created 2020-06-27)")
  (custom-theme-set-faces 'spacemacs-dark-customizations
                          '(default
                             ((t
                               (:family "Hack" :background "#1c1e1f" :foreground "#fbf8ef"))))
                          '(variable-pitch
                            ((t
                              (:family "Source Sans Pro"))))
                          '(header-line
                            ((t
                              (:background nil :inherit nil))))
                          '(show-paren-match
                            ((t
                              (:background "#f92672" :foreground "#1c1e1f"))))
                          '(magit-section-heading
                            ((t
                              (:foreground "#f92672"))))
                          '(magit-header-line
                            ((t
                              (:background nil :foreground "#1c1e1f" :box nil))))
                          '(magit-diff-hunk-heading
                            ((t
                              (:background "#525254" :foreground "#bbb"))))
                          '(magit-diff-hunk-heading-highlight
                            ((t
                              (:background "#525254" :foreground "#ffffff"))))
                          '(tooltip
                            ((t
                              (:foreground "#bbb" :background "#1c1c1c"))))
                          '(mode-line
                            ((t
                              (:background "#1c1c1c"))))
                          '(mode-line-inactive
                            ((t nil)))
                          '(powerline-active1
                            ((t nil)))
                          '(powerline-active2
                            ((t nil)))
                          '(powerline-inactive1
                            ((t nil)))
                          '(powerline-inactive2
                            ((t nil)))
                          '(highlight
                            ((t
                              (:background "#39393d" :foreground "#ffffff"))))
                          '(hl-line
                            ((t
                              (:background "#2d2e2e"))))
                          '(org-document-title
                            ((t
                              (:inherit variable-pitch :height 1.3 :weight normal :foreground "#bbb"))))
                          '(org-document-info
                            ((t
                              (:foreground "#bbb" :slant italic))))
                          '(org-archived
                            ((t nil)))
                          '(org-level-1
                            ((t
                              (:inherit variable-pitch :height 1.3 :weight bold :foreground "#f92672" :background "#1c1e1f"))))
                          '(org-level-2
                            ((t
                              (:inherit variable-pitch :weight bold :height 1.2 :foreground "#bbb" :background "#1c1e1f"))))
                          '(org-level-3
                            ((t
                              (:inherit variable-pitch :weight bold :height 1.1 :foreground "#8FA1B3" :background "#1c1e1f"))))
                          '(org-level-4
                            ((t
                              (:inherit variable-pitch :weight bold :height 1.1 :foreground "#8FA1B3" :background "#1c1e1f"))))
                          '(org-level-5
                            ((t
                              (:inherit variable-pitch :weight bold :height 1.1 :foreground "#8FA1B3" :background "#1c1e1f"))))
                          '(org-level-6
                            ((t
                              (:inherit variable-pitch :weight bold :height 1.1 :foreground "#8FA1B3" :background "#1c1e1f"))))
                          '(org-level-7
                            ((t
                              (:inherit variable-pitch :weight bold :height 1.1 :foreground "#8FA1B3" :background "#1c1e1f"))))
                          '(org-level-8
                            ((t
                              (:inherit variable-pitch :weight bold :height 1.1 :foreground "#8FA1B3" :background "#1c1e1f"))))
                          '(org-headline-done
                            (nil))
                          '(org-quote
                            ((t
                              (:background "#1c1e1f" :family "Hack"))))
                          '(org-block
                            ((t
                              (:background "#1c1e1f" :family "Hack"))))
                          '(org-block-begin-line
                            ((t
                              (:background "#1c1e1f"))))
                          '(org-block-end-line
                            ((t
                              (:background "#1c1e1f"))))
                          '(org-meta-line
                            ((t
                              (:foreground "#525254"))))
                          '(org-document-info-keyword
                            ((t
                              (:foreground "#525254"))))
                          '(org-link
                            ((t
                              (:underline nil :weight normal :foreground "#8FA1B3"))))
                          '(org-special-keyword
                            ((t
                              (:height 0.9 :foreground "#525254"))))
                          '(org-property-value
                            ((t
                              (:height 0.9 :foreground "#525254"))))
                          '(org-drawer
                            ((t
                              (:height 0.9 :foreground "#525254"))))
                          '(org-todo
                            ((t
                              (:foreground "#fd971f" :background "#1c1e1f"))))
                          '(org-done
                            ((t
                              (:inherit variable-pitch :foreground "#008b8b" :background "#1c1e1f"))))
                          '(org-agenda-current-time
                            ((t
                              (:foreground "#8FA1B3"))))
                          '(org-hide
                            ((t nil)))
                          '(org-indent
                            ((t
                              (:inherit org-hide))))
                          '(org-time-grid
                            ((t
                              (:foreground "#525254"))))
                          '(org-warning
                            ((t
                              (:foreground "#fd971f"))))
                          '(org-date
                            ((t nil)))
                          '(org-agenda-structure
                            ((t
                              (:height 1.3 :foreground "#727280" :weight normal :inherit variable-pitch))))
                          '(org-agenda-date
                            ((t
                              (:foreground "#727280"))))
                          '(org-agenda-date-today
                            ((t
                              (:height 1.5 :foreground "#f92672"))))
                          '(org-agenda-date-weekend
                            ((t
                              (:inherit org-agenda-date))))
                          '(org-scheduled
                            ((t
                              (:foreground "#bbb"))))
                          '(org-upcoming-deadline
                            ((t
                              (:foreground "#f92672"))))
                          '(org-scheduled-today
                            ((t
                              (:foreground "#ffffff"))))
                          '(org-scheduled-previously
                            ((t
                              (:foreground "#8FA1B3"))))
                          '(org-agenda-done
                            ((t
                              (:inherit nil :foreground "#727280"))))
                          '(org-ellipsis
                            ((t
                              (:underline nil :foreground "#525254"))))
                          '(org-tag
                            ((t
                              (:foreground "#727280"))))
                          '(org-table
                            ((t
                              (:background nil :family "Hack"))))
                          '(org-code
                            ((t
                              (:inherit font-lock-builtin-face))))
                          '(font-latex-sectioning-0-face
                            ((t
                              (:foreground "#66d9ef" :height 1.2))))
                          '(font-latex-sectioning-1-face
                            ((t
                              (:foreground "#66d9ef" :height 1.1))))
                          '(font-latex-sectioning-2-face
                            ((t
                              (:foreground "#66d9ef" :height 1.1))))
                          '(font-latex-sectioning-3-face
                            ((t
                              (:foreground "#66d9ef" :height 1.0))))
                          '(font-latex-sectioning-4-face
                            ((t
                              (:foreground "#66d9ef" :height 1.0))))
                          '(font-latex-sectioning-5-face
                            ((t
                              (:foreground "#66d9ef" :height 1.0))))
                          '(font-latex-verbatim-face
                            ((t
                              (:foreground "#fd971f"))))
                          '(spacemacs-normal-face
                            ((t
                              (:background "#1c1e1f" :foreground "#ffffff"))))
                          '(spacemacs-evilified-face
                            ((t
                              (:background "#1c1e1f" :foreground "#ffffff"))))
                          '(spacemacs-lisp-face
                            ((t
                              (:background "#1c1e1f" :foreground "#ffffff"))))
                          '(spacemacs-emacs-face
                            ((t
                              (:background "#1c1e1f" :foreground "#ffffff"))))
                          '(spacemacs-motion-face
                            ((t
                              (:background "#1c1e1f" :foreground "#ffffff"))))
                          '(spacemacs-visual-face
                            ((t
                              (:background "#1c1e1f" :foreground "#ffffff"))))
                          '(spacemacs-hybrid-face
                            ((t
                              (:background "#1c1e1f" :foreground "#ffffff"))))
                          '(bm-persistent-face
                            ((t
                              (:background "#008b8b" :foreground "#ffffff"))))
                          '(helm-selection
                            ((t
                              (:background "#39393d"))))
                          '(helm-match
                            ((t
                              (:foreground "#f92672"))))
                          '(cfw:face-title
                            ((t
                              (:height 2.0 :inherit variable-pitch :weight bold :foreground "#727280"))))
                          '(cfw:face-holiday
                            ((t
                              (:foreground "#fd971f"))))
                          '(cfw:face-saturday
                            ((t
                              (:foreground "#727280" :weight bold))))
                          '(cfw:face-sunday
                            ((t
                              (:foreground "#727280"))))
                          '(cfw:face-periods
                            ((t
                              (:foreground "#008b8b"))))
                          '(cfw:face-annotation
                            ((t
                              (:foreground "#727280"))))
                          '(cfw:face-select
                            ((t
                              (:background "#39393d"))))
                          '(cfw:face-toolbar-button-off
                            ((t
                              (:foreground "#727280"))))
                          '(cfw:face-toolbar-button-on
                            ((t
                              (:foreground "#66d9ef" :weight bold))))
                          '(cfw:face-day-title
                            ((t
                              (:foreground "#727280"))))
                          '(cfw:face-default-content
                            ((t
                              (:foreground "#008b8b"))))
                          '(cfw:face-disable
                            ((t
                              (:foreground "#727280"))))
                          '(cfw:face-today
                            ((t
                              (:background "#39393d" :weight bold))))
                          '(cfw:face-toolbar
                            ((t
                              (:inherit default))))
                          '(cfw:face-today-title
                            ((t
                              (:background "#f92672" :foreground "#ffffff"))))
                          '(cfw:face-grid
                            ((t
                              (:foreground "#525254"))))
                          '(cfw:face-header
                            ((t
                              (:foreground "#f92672" :weight bold))))
                          '(cfw:face-default-day
                            ((t
                              (:foreground "#ffffff"))))
                          '(dired-subtree-depth-1-face
                            ((t
                              (:background nil))))
                          '(dired-subtree-depth-2-face
                            ((t
                              (:background nil))))
                          '(dired-subtree-depth-3-face
                            ((t
                              (:background nil))))
                          '(dired-subtree-depth-4-face
                            ((t
                              (:background nil))))
                          '(dired-subtree-depth-5-face
                            ((t
                              (:background nil))))
                          '(dired-subtree-depth-6-face
                            ((t
                              (:background nil))))
                          '(nlinum-current-line
                            ((t
                              (:foreground "#fd971f"))))
                          '(vertical-border
                            ((t
                              (:background "#39393d" :foreground "#39393d"))))
                          '(which-key-command-description-face
                            ((t
                              (:foreground "#66d9ef"))))
                          '(flycheck-error
                            ((t
                              (:background nil))))
                          '(flycheck-warning
                            ((t
                              (:background nil))))
                          '(font-lock-string-face
                            ((t
                              (:foreground "#b6e63e"))))
                          '(font-lock-comment-face
                            ((t
                              (:foreground "#727280" :slant italic))))
                          '(elfeed-search-unread-title-face
                            ((t
                              (:weight bold))))
                          '(helm-ff-symlink
                            ((t
                              (:foreground "#8FA1B3"))))
                          '(region
                            ((t
                              (:background "#39393d")))))
  (provide-theme 'spacemacs-dark-customizations))
#+end_src

#+begin_src emacs-lisp :tangle no :results code replace  :wrap "src emacs-lisp :tangle tangle/spacemacs-light-customizations-theme.el" :exports both
`(progn
   (deftheme spacemacs-light-customizations
     "My customizations to spacemacs-light (Created 2020-06-27)")
   (custom-theme-set-faces
    'spacemacs-light-customizations
    ,@(prep-custom-theme-set-faces
       (quote
        <<colors>>)
       <<faces-spacemacs-light>>))
    (provide-theme 'spacemacs-light-customizations))
#+end_src

#+RESULTS:
#+begin_src emacs-lisp :tangle tangle/spacemacs-light-customizations-theme.el
(progn
  (deftheme spacemacs-light-customizations "My customizations to spacemacs-light (Created 2020-06-27)")
  (custom-theme-set-faces 'spacemacs-light-customizations
                          '(header-line
                            ((t
                              (:background nil :inherit nil))))
                          '(show-paren-match
                            ((t nil)))
                          '(magit-section-heading
                            ((t nil)))
                          '(magit-header-line
                            ((t
                              (:background nil :foreground "#fbf8ef" :box nil))))
                          '(magit-diff-hunk-heading
                            ((t nil)))
                          '(magit-diff-hunk-heading-highlight
                            ((t nil)))
                          '(tooltip
                            ((t nil)))
                          '(mode-line
                            ((t
                              (:background "#fbf8ef" :box nil))))
                          '(mode-line-inactive
                            ((t
                              (:box nil))))
                          '(powerline-active1
                            ((t
                              (:background "#fbf8ef"))))
                          '(powerline-active2
                            ((t
                              (:background "#fbf8ef"))))
                          '(powerline-inactive1
                            ((t
                              (:background "#fbf8ef"))))
                          '(powerline-inactive2
                            ((t
                              (:background "#fbf8ef"))))
                          '(highlight
                            ((t
                              (:background "#efeae9"))))
                          '(hl-line
                            ((t nil)))
                          '(org-document-title
                            ((t
                              (:inherit nil :height 1.8 :foreground "#1c1e1f" :underline nil))))
                          '(org-document-info
                            ((t
                              (:height 1.2 :slant italic))))
                          '(org-archived
                            ((t
                              (:inherit shadow :height 0.6))))
                          '(org-level-1
                            ((t
                              (:height 1.6 :weight normal :slant normal :foreground "#1c1e1f"))))
                          '(org-level-2
                            ((t
                              (:weight normal :height 1.3 :slant italic :foreground "#1c1e1f"))))
                          '(org-level-3
                            ((t
                              (:weight normal :slant italic :height 1.2 :foreground "#1c1e1f"))))
                          '(org-level-4
                            ((t
                              (:weight normal :slant italic :height 1.1 :foreground "#1c1e1f"))))
                          '(org-level-5
                            ((t nil)))
                          '(org-level-6
                            ((t nil)))
                          '(org-level-7
                            ((t nil)))
                          '(org-level-8
                            ((t nil)))
                          '(org-quote
                            ((t nil)))
                          '(org-block
                            ((t
                              (:background nil :height 0.9 :foreground "#1c1e1f" :family "Hack"))))
                          '(org-block-begin-line
                            ((t
                              (:background nil :height 0.8 :family "Hack" :foreground "#8FA1B3"))))
                          '(org-block-end-line
                            ((t
                              (:background nil :height 0.8 :family "Hack" :foreground "#8FA1B3"))))
                          '(org-meta-line
                            ((t
                              (:height 0.8 :foreground "#bbb"))))
                          '(org-document-info-keyword
                            ((t
                              (:height 0.8 :foreground "#bbb"))))
                          '(org-link
                            ((t
                              (:foreground "#fd971f"))))
                          '(org-special-keyword
                            ((t
                              (:family "Hack" :height 0.8))))
                          '(org-property-value
                            ((t
                              (:family "Hack" :height 0.8))))
                          '(org-drawer
                            ((t
                              (:family "Hack" :height 0.8))))
                          '(org-todo
                            ((t nil)))
                          '(org-done
                            ((t nil)))
                          '(org-agenda-current-time
                            ((t nil)))
                          '(org-hide
                            ((t
                              (:foreground "#fbf8ef"))))
                          '(org-indent
                            ((t
                              (:inherit
                               (org-hide fixed-pitch)))))
                          '(org-time-grid
                            ((t nil)))
                          '(org-warning
                            ((t nil)))
                          '(org-date
                            ((t
                              (:family "Hack" :height 0.8))))
                          '(org-agenda-structure
                            ((t nil)))
                          '(org-agenda-date
                            ((t
                              (:foreground "#727280"))))
                          '(org-agenda-date-today
                            ((t
                              (:height 1.2))))
                          '(org-agenda-date-weekend
                            ((t nil)))
                          '(org-scheduled
                            ((t
                              (:foreground "#4f774f"))))
                          '(org-upcoming-deadline
                            ((t nil)))
                          '(org-scheduled-today
                            ((t
                              (:foreground "#1c661c"))))
                          '(org-scheduled-previously
                            ((t
                              (:foreground "#002900"))))
                          '(org-agenda-done
                            ((t
                              (:foreground "#727280"))))
                          '(org-ellipsis
                            ((t
                              (:underline nil :foreground "#525254"))))
                          '(org-tag
                            ((t
                              (:foreground "#727280"))))
                          '(org-table
                            ((t
                              (:inherit fixed-pitch :height 0.9 :background "#fbf8ef"))))
                          '(org-code
                            ((t
                              (:inherit fixed-pitch :foreground "#525254" :height 0.9))))
                          '(font-latex-sectioning-0-face
                            ((t nil)))
                          '(font-latex-sectioning-1-face
                            ((t nil)))
                          '(font-latex-sectioning-2-face
                            ((t nil)))
                          '(font-latex-sectioning-3-face
                            ((t nil)))
                          '(font-latex-sectioning-4-face
                            ((t nil)))
                          '(font-latex-sectioning-5-face
                            ((t nil)))
                          '(font-latex-verbatim-face
                            ((t nil)))
                          '(spacemacs-normal-face
                            ((t nil)))
                          '(spacemacs-evilified-face
                            ((t nil)))
                          '(spacemacs-lisp-face
                            ((t nil)))
                          '(spacemacs-emacs-face
                            ((t nil)))
                          '(spacemacs-motion-face
                            ((t nil)))
                          '(spacemacs-visual-face
                            ((t nil)))
                          '(spacemacs-hybrid-face
                            ((t nil)))
                          '(bm-persistent-face
                            ((t nil)))
                          '(helm-selection
                            ((t nil)))
                          '(helm-match
                            ((t nil)))
                          '(cfw:face-title
                            ((t nil)))
                          '(cfw:face-holiday
                            ((t nil)))
                          '(cfw:face-saturday
                            ((t nil)))
                          '(cfw:face-sunday
                            ((t nil)))
                          '(cfw:face-periods
                            ((t nil)))
                          '(cfw:face-annotation
                            ((t nil)))
                          '(cfw:face-select
                            ((t nil)))
                          '(cfw:face-toolbar-button-off
                            ((t nil)))
                          '(cfw:face-toolbar-button-on
                            ((t nil)))
                          '(cfw:face-day-title
                            ((t nil)))
                          '(cfw:face-default-content
                            ((t nil)))
                          '(cfw:face-disable
                            ((t nil)))
                          '(cfw:face-today
                            ((t nil)))
                          '(cfw:face-toolbar
                            ((t nil)))
                          '(cfw:face-today-title
                            ((t nil)))
                          '(cfw:face-grid
                            ((t nil)))
                          '(cfw:face-header
                            ((t nil)))
                          '(cfw:face-default-day
                            ((t nil)))
                          '(dired-subtree-depth-1-face
                            ((t
                              (:background nil))))
                          '(dired-subtree-depth-2-face
                            ((t
                              (:background nil))))
                          '(dired-subtree-depth-3-face
                            ((t
                              (:background nil))))
                          '(dired-subtree-depth-4-face
                            ((t
                              (:background nil))))
                          '(dired-subtree-depth-5-face
                            ((t
                              (:background nil))))
                          '(dired-subtree-depth-6-face
                            ((t
                              (:background nil))))
                          '(nlinum-current-line
                            ((t
                              (:foreground "#1c1e1f"))))
                          '(vertical-border
                            ((t nil)))
                          '(which-key-command-description-face
                            ((t nil)))
                          '(flycheck-error
                            ((t nil)))
                          '(flycheck-warning
                            ((t nil)))
                          '(font-lock-string-face
                            ((t nil)))
                          '(font-lock-comment-face
                            ((t
                              (:background nil :foreground "#727280" :slant italic))))
                          '(elfeed-search-unread-title-face
                            ((t
                              (:weight bold))))
                          '(helm-ff-symlink
                            ((t nil)))
                          '(region
                            ((t nil))))
  (provide-theme 'spacemacs-light-customizations))
#+end_src

Now we just have to link the tangled themes to the ~load-path~
#+BEGIN_SRC shell :results silent :noweb-ref symlinks :tangle no
ln -siv $(pwd)/tangle/spacemacs-dark-customizations-theme.el ~/.emacs.d/
ln -siv $(pwd)/tangle/spacemacs-light-customizations-theme.el ~/.emacs.d/
#+END_SRC
**** Colors
:PROPERTIES:
:ID:       82021d54-89d6-4712-8e5a-df2fc6177c96
:END:
#+begin_src emacs-lisp :noweb-ref colors :tangle no
((bg-white           "#fbf8ef")
 (bg-light           "#222425")
 (bg-dark            "#1c1e1f")
 (bg-darker          "#1c1c1c")
 (fg-white           "#ffffff")
 (shade-white        "#efeae9")
 (fg-light           "#655370")
 (dark-cyan          "#008b8b")
 (light-green        "#4f774f") ;;#3f773f
 (dark-green         "#1c661c")
 (dark-green2        "#002900")
 (region-dark        "#2d2e2e")
 (region             "#39393d")
 (slate              "#8FA1B3")
 (keyword            "#f92672")
 (comment            "#525254")
 (builtin            "#fd971f")
 (purple             "#9c91e4")
 (doc                "#727280")
 (type               "#66d9ef")
 (string             "#b6e63e")
 (gray-dark          "#999")
 (gray               "#bbb")
 (sans-font          "Source Sans Pro")
 (serif-font         "Merriweather")
 (et-font            "EtBookOt")
 (sans-mono-font     "Hack")
 ;; (serif-mono-font    "Verily Serif Mono")
 (serif-mono-font    "cmu typewriter text")
 )
#+end_src
**** Faces
:PROPERTIES:
:ID:       a3b74d3b-675e-426d-b675-e70dcfd3d2b6
:END:
#+begin_src emacs-lisp :noweb-ref faces-spacemacs-light :tangle no
;; light
'(
  ;; '(default ((t (:family ,sans-mono-font :background ,bg-white :foreground ,bg-dark
  ;;                        ;; :height 75
  ;;                        ))))
  ;; '(variable-pitch ((t (:family ,et-font :background nil :foreground ,bg-dark :height 1.2))))
  '(header-line ((t (:background nil :inherit nil))))
  '(show-paren-match ((t nil)))
  '(magit-section-heading ((t nil)))
  '(magit-header-line ((t (:background nil :foreground ,bg-white :box nil))))
  '(magit-diff-hunk-heading ((t nil)))
  '(magit-diff-hunk-heading-highlight ((t nil)))
  '(tooltip ((t nil)))
  '(mode-line ((t (:background ,bg-white :box nil))))
  '(mode-line-inactive ((t (:box nil))))
  '(powerline-active1 ((t (:background ,bg-white))))
  '(powerline-active2 ((t (:background ,bg-white))))
  '(powerline-inactive1 ((t (:background ,bg-white))))
  '(powerline-inactive2 ((t (:background ,bg-white))))
  '(highlight ((t (:background ,shade-white))))
  '(hl-line ((t nil)))
  '(org-document-title ((t (:inherit nil :height 1.8 :foreground ,bg-dark :underline nil))))
  '(org-document-info ((t (:height 1.2 :slant italic))))
  '(org-archived ((t (:inherit shadow :height 0.6))))
  '(org-level-1 ((t (:height 1.6 :weight normal :slant normal :foreground ,bg-dark))))
  '(org-level-2 ((t (:weight normal :height 1.3 :slant italic :foreground ,bg-dark))))
  '(org-level-3 ((t (:weight normal :slant italic :height 1.2 :foreground ,bg-dark))))
  '(org-level-4 ((t (:weight normal :slant italic :height 1.1 :foreground ,bg-dark))))
  '(org-level-5 ((t nil)))
  '(org-level-6 ((t nil)))
  '(org-level-7 ((t nil)))
  '(org-level-8 ((t nil)))
  ;; '(org-headline-done ((t (:family ,et-font))))
  '(org-quote ((t nil)))
  '(org-block ((t (:background nil :height 0.9 :foreground ,bg-dark :family ,sans-mono-font))))
  '(org-block-begin-line ((t (:background nil :height 0.8 :family ,sans-mono-font :foreground ,slate))))
  '(org-block-end-line ((t (:background nil :height 0.8 :family ,sans-mono-font :foreground ,slate))))
  '(org-meta-line ((t (:height 0.8 :foreground ,gray))))
  '(org-document-info-keyword ((t (:height 0.8 :foreground ,gray))))
  '(org-link ((t (:foreground ,builtin))))
  '(org-special-keyword ((t (:family ,sans-mono-font :height 0.8))))
  '(org-property-value ((t (:family ,sans-mono-font :height 0.8))))
  '(org-drawer ((t (:family ,sans-mono-font :height 0.8))))
  '(org-todo ((t nil)))
  '(org-done ((t nil)))
  '(org-agenda-current-time ((t nil)))
  '(org-hide ((t (:foreground ,bg-white))))
  '(org-indent ((t (:inherit (org-hide fixed-pitch)))))
  '(org-time-grid ((t nil)))
  '(org-warning ((t nil)))
  '(org-date ((t (:family ,sans-mono-font :height 0.8))))
  '(org-agenda-structure ((t nil)))
  '(org-agenda-date ((t (:foreground ,doc))))
  '(org-agenda-date-today ((t (:height 1.2))))
  '(org-agenda-date-weekend ((t nil)))
  '(org-scheduled ((t (:foreground ,light-green))))
  '(org-upcoming-deadline ((t nil)))
  '(org-scheduled-today ((t (:foreground ,dark-green))))
  '(org-scheduled-previously ((t (:foreground ,dark-green2))))
  '(org-agenda-done ((t (:foreground ,doc))))
  '(org-ellipsis ((t (:underline nil :foreground ,comment))))
  '(org-tag ((t (:foreground ,doc))))
  '(org-table ((t (:inherit fixed-pitch :height 0.9 :background ,bg-white))))
  '(org-code ((t (:inherit fixed-pitch :foreground ,comment :height 0.9))))
  '(font-latex-sectioning-0-face ((t nil)))
  '(font-latex-sectioning-1-face ((t nil)))
  '(font-latex-sectioning-2-face ((t nil)))
  '(font-latex-sectioning-3-face ((t nil)))
  '(font-latex-sectioning-4-face ((t nil)))
  '(font-latex-sectioning-5-face ((t nil)))
  '(font-latex-verbatim-face ((t nil)))
  '(spacemacs-normal-face ((t nil)))
  '(spacemacs-evilified-face ((t nil)))
  '(spacemacs-lisp-face ((t nil)))
  '(spacemacs-emacs-face ((t nil)))
  '(spacemacs-motion-face ((t nil)))
  '(spacemacs-visual-face ((t nil)))
  '(spacemacs-hybrid-face ((t nil)))
  '(bm-persistent-face ((t nil)))
  '(helm-selection ((t nil)))
  '(helm-match ((t nil)))
  '(cfw:face-title ((t nil)))
  '(cfw:face-holiday ((t nil)))
  '(cfw:face-saturday ((t nil)))
  '(cfw:face-sunday ((t nil)))
  '(cfw:face-periods ((t nil)))
  '(cfw:face-annotation ((t nil)))
  '(cfw:face-select ((t nil)))
  '(cfw:face-toolbar-button-off ((t nil)))
  '(cfw:face-toolbar-button-on ((t nil)))
  '(cfw:face-day-title ((t nil)))
  '(cfw:face-default-content ((t nil)))
  '(cfw:face-disable ((t nil)))
  '(cfw:face-today ((t nil)))
  '(cfw:face-toolbar ((t nil)))
  '(cfw:face-today-title ((t nil)))
  '(cfw:face-grid ((t nil)))
  '(cfw:face-header ((t nil)))
  '(cfw:face-default-day ((t nil)))
  '(dired-subtree-depth-1-face ((t (:background nil))))
  '(dired-subtree-depth-2-face ((t (:background nil))))
  '(dired-subtree-depth-3-face ((t (:background nil))))
  '(dired-subtree-depth-4-face ((t (:background nil))))
  '(dired-subtree-depth-5-face ((t (:background nil))))
  '(dired-subtree-depth-6-face ((t (:background nil))))
  '(nlinum-current-line ((t (:foreground ,bg-dark))))
  '(vertical-border ((t nil)))
  '(which-key-command-description-face ((t nil)))
  '(flycheck-error ((t nil)))
  '(flycheck-warning ((t nil)))
  '(font-lock-string-face ((t nil)))
  '(font-lock-comment-face ((t (:background nil :foreground ,doc :slant italic))))
  '(elfeed-search-unread-title-face ((t (:weight bold))))
  '(helm-ff-symlink ((t nil)))
  '(region ((t nil))))
#+end_src
#+begin_src emacs-lisp :noweb-ref faces-spacemacs-dark :tangle no
;; dark
'('(default ((t (:family ,sans-mono-font :background ,bg-dark :foreground ,bg-white))))
  '(variable-pitch ((t (:family ,sans-font))))
  '(header-line ((t (:background nil :inherit nil))))
  '(show-paren-match ((t (:background ,keyword :foreground ,bg-dark))))
  '(magit-section-heading ((t (:foreground ,keyword))))
  '(magit-header-line ((t (:background nil :foreground ,bg-dark :box nil))))
  '(magit-diff-hunk-heading ((t (:background ,comment :foreground ,gray))))
  '(magit-diff-hunk-heading-highlight ((t (:background ,comment :foreground ,fg-white))))
  '(tooltip ((t (:foreground ,gray :background ,bg-darker))))
  '(mode-line ((t (:background ,bg-darker))))
  '(mode-line-inactive ((t nil)))
  '(powerline-active1 ((t nil)))
  '(powerline-active2 ((t nil)))
  '(powerline-inactive1 ((t nil)))
  '(powerline-inactive2 ((t nil)))
  '(highlight ((t (:background ,region :foreground ,fg-white))))
  '(hl-line ((t (:background ,region-dark))))
  '(org-document-title ((t (:inherit variable-pitch :height 1.3 :weight normal :foreground ,gray))))
  '(org-document-info ((t (:foreground ,gray :slant italic))))
  '(org-archived ((t nil)))
  '(org-level-1 ((t (:inherit variable-pitch :height 1.3 :weight bold :foreground ,keyword :background ,bg-dark))))
  '(org-level-2 ((t (:inherit variable-pitch :weight bold :height 1.2 :foreground ,gray :background ,bg-dark))))
  '(org-level-3 ((t (:inherit variable-pitch :weight bold :height 1.1 :foreground ,slate :background ,bg-dark))))
  '(org-level-4 ((t (:inherit variable-pitch :weight bold :height 1.1 :foreground ,slate :background ,bg-dark))))
  '(org-level-5 ((t (:inherit variable-pitch :weight bold :height 1.1 :foreground ,slate :background ,bg-dark))))
  '(org-level-6 ((t (:inherit variable-pitch :weight bold :height 1.1 :foreground ,slate :background ,bg-dark))))
  '(org-level-7 ((t (:inherit variable-pitch :weight bold :height 1.1 :foreground ,slate :background ,bg-dark))))
  '(org-level-8 ((t (:inherit variable-pitch :weight bold :height 1.1 :foreground ,slate :background ,bg-dark))))
  '(org-headline-done (nil))
  '(org-quote ((t (:background ,bg-dark :family ,sans-mono-font))))
  '(org-block ((t (:background ,bg-dark :family ,sans-mono-font))))
  '(org-block-begin-line ((t (:background ,bg-dark))))
  '(org-block-end-line ((t (:background ,bg-dark))))
  '(org-meta-line ((t (:foreground ,comment))))
  '(org-document-info-keyword ((t (:foreground ,comment))))
  '(org-link ((t (:underline nil :weight normal :foreground ,slate))))
  '(org-special-keyword ((t (:height 0.9 :foreground ,comment))))
  '(org-property-value ((t (:height 0.9 :foreground ,comment))))
  '(org-drawer ((t (:height 0.9 :foreground ,comment))))
  '(org-todo ((t (:foreground ,builtin :background ,bg-dark))))
  '(org-done ((t (:inherit variable-pitch :foreground ,dark-cyan :background ,bg-dark))))
  '(org-agenda-current-time ((t (:foreground ,slate))))
  '(org-hide ((t nil)))
  '(org-indent ((t (:inherit org-hide))))
  '(org-time-grid ((t (:foreground ,comment))))
  '(org-warning ((t (:foreground ,builtin))))
  '(org-date ((t nil)))
  '(org-agenda-structure ((t (:height 1.3 :foreground ,doc :weight normal :inherit variable-pitch))))
  '(org-agenda-date ((t (:foreground ,doc))))
  '(org-agenda-date-today ((t (:height 1.5 :foreground ,keyword))))
  '(org-agenda-date-weekend ((t (:inherit org-agenda-date))))
  '(org-scheduled ((t (:foreground ,gray))))
  '(org-upcoming-deadline ((t (:foreground ,keyword))))
  '(org-scheduled-today ((t (:foreground ,fg-white))))
  '(org-scheduled-previously ((t (:foreground ,slate))))
  '(org-agenda-done ((t (:inherit nil :foreground ,doc))))
  '(org-ellipsis ((t (:underline nil :foreground ,comment))))
  '(org-tag ((t (:foreground ,doc))))
  '(org-table ((t (:background nil :family ,sans-mono-font))))
  '(org-code ((t (:inherit font-lock-builtin-face))))
  '(font-latex-sectioning-0-face ((t (:foreground ,type :height 1.2))))
  '(font-latex-sectioning-1-face ((t (:foreground ,type :height 1.1))))
  '(font-latex-sectioning-2-face ((t (:foreground ,type :height 1.1))))
  '(font-latex-sectioning-3-face ((t (:foreground ,type :height 1.0))))
  '(font-latex-sectioning-4-face ((t (:foreground ,type :height 1.0))))
  '(font-latex-sectioning-5-face ((t (:foreground ,type :height 1.0))))
  '(font-latex-verbatim-face ((t (:foreground ,builtin))))
  '(spacemacs-normal-face ((t (:background ,bg-dark :foreground ,fg-white))))
  '(spacemacs-evilified-face ((t (:background ,bg-dark :foreground ,fg-white))))
  '(spacemacs-lisp-face ((t (:background ,bg-dark :foreground ,fg-white))))
  '(spacemacs-emacs-face ((t (:background ,bg-dark :foreground ,fg-white))))
  '(spacemacs-motion-face ((t (:background ,bg-dark :foreground ,fg-white))))
  '(spacemacs-visual-face ((t (:background ,bg-dark :foreground ,fg-white))))
  '(spacemacs-hybrid-face ((t (:background ,bg-dark :foreground ,fg-white))))
  '(bm-persistent-face ((t (:background ,dark-cyan :foreground ,fg-white))))
  '(helm-selection ((t (:background ,region))))
  '(helm-match ((t (:foreground ,keyword))))
  '(cfw:face-title ((t (:height 2.0 :inherit variable-pitch :weight bold :foreground ,doc))))
  '(cfw:face-holiday ((t (:foreground ,builtin))))
  '(cfw:face-saturday ((t (:foreground ,doc :weight bold))))
  '(cfw:face-sunday ((t (:foreground ,doc))))
  '(cfw:face-periods ((t (:foreground ,dark-cyan))))
  '(cfw:face-annotation ((t (:foreground ,doc))))
  '(cfw:face-select ((t (:background ,region))))
  '(cfw:face-toolbar-button-off ((t (:foreground ,doc))))
  '(cfw:face-toolbar-button-on ((t (:foreground ,type :weight bold))))
  '(cfw:face-day-title ((t (:foreground ,doc))))
  '(cfw:face-default-content ((t (:foreground ,dark-cyan))))
  '(cfw:face-disable ((t (:foreground ,doc))))
  '(cfw:face-today ((t (:background ,region :weight bold))))
  '(cfw:face-toolbar ((t (:inherit default))))
  '(cfw:face-today-title ((t (:background ,keyword :foreground ,fg-white))))
  '(cfw:face-grid ((t (:foreground ,comment))))
  '(cfw:face-header ((t (:foreground ,keyword :weight bold))))
  '(cfw:face-default-day ((t (:foreground ,fg-white))))
  '(dired-subtree-depth-1-face ((t (:background nil))))
  '(dired-subtree-depth-2-face ((t (:background nil))))
  '(dired-subtree-depth-3-face ((t (:background nil))))
  '(dired-subtree-depth-4-face ((t (:background nil))))
  '(dired-subtree-depth-5-face ((t (:background nil))))
  '(dired-subtree-depth-6-face ((t (:background nil))))
  '(nlinum-current-line ((t (:foreground ,builtin))))
  '(vertical-border ((t (:background ,region :foreground ,region))))
  '(which-key-command-description-face ((t (:foreground ,type))))
  '(flycheck-error ((t (:background nil))))
  '(flycheck-warning ((t (:background nil))))
  '(font-lock-string-face ((t (:foreground ,string))))
  '(font-lock-comment-face ((t (:foreground ,doc :slant italic))))
  '(elfeed-search-unread-title-face ((t (:weight bold))))
  '(helm-ff-symlink ((t (:foreground ,slate))))
  '(region ((t (:background ,region)))))
#+end_src
*** Misc
**** Diminish buffer-face-mode
=Face-remap= is a library for basic face remapping. =Buffer-face-mode=
is enabled when using =variable-pitch-mode= to show the face defined
in =variable-pitch= instead of =default=.
#+begin_src emacs-lisp
(use-package face-remap
  :delight (buffer-face-mode))
#+end_src
**** Scaling the height of the =default= face.
When switching between monitors with different resolution, scaling the
=default= face can be used to in-/decreases the size of text and UI elements
(modeline, â€¦) to a more readable size.
#+begin_src emacs-lisp
(defun fpi/scale-default-face (&optional arg)
  "Increase height of face default."
  (interactive "P")
  (let* ((height (face-attribute 'default :height))
        (scale (if arg -10 10))
        (new (+ height scale)))
    (set-face-attribute 'default nil :height new)
    (message "Default height: %s. Use +,- for further adjustment" new)
    (set-transient-map
     (let ((map (make-sparse-keymap)))
       (define-key map (vector '(?-)) (lambda () (interactive) (fpi/scale-default-face t)))
       (define-key map (vector '(?+)) (lambda () (interactive) (fpi/scale-default-face nil)))
       map))))
#+end_src
#+begin_src emacs-lisp :tangle no :noweb-ref fpi-bindings
(fpi/define-key fpi-map (kbd "+") #'fpi/scale-default-face "Zoom")
(fpi/define-key fpi-map (kbd "-") (lambda () (interactive) (fpi/scale-default-face t)) "Unzoom")
#+end_src
** User info
Set ~user-full-name~ and ~user-mail-address~. These are set in
[[file:emacs-private.el.gpg::1][emacs-private.el.gpg]].

#+begin_src emacs-lisp
(setq user-full-name private/user-full-name
      user-mail-address private/user-mail-address)
#+end_src
** Garbage collection
Give a message when Emacs does garbage collection and increase the thresholds for triggering it.
#+begin_src emacs-lisp
(use-package emacs
  :custom
  (garbage-collection-messages t)
  (gc-cons-threshold 80000000)
  (gc-cons-percentage 0.3))
#+end_src
** Desktop module
This saves the state emacs was in.
#+begin_src emacs-lisp
(use-package desktop
  :init
  (setq desktop-dirname user-emacs-directory)
  (setq desktop-base-file-name "desktop")
  (setq desktop-globals-to-clear nil)
  (setq desktop-missing-file-warning nil)
  (setq desktop-restore-eager 5)
  (setq desktop-restore-frames nil)
  (setq desktop-save 'ask-if-new)
  :config
  (desktop-save-mode 1))
#+end_src
** Customize
#+BEGIN_SRC emacs-lisp
(use-package cus-edit
  :custom
  (custom-file (expand-file-name "custom.el" user-emacs-directory))
  :hook
  (after-init . (lambda ()
                  (unless (file-exists-p custom-file)
                    (write-region "" nil custom-file))
                  (load custom-file))))
#+END_SRC
** File and input history
*** Recentf
#+begin_src emacs-lisp
(use-package recentf
  :init
  (setq recentf-save-file (expand-file-name "recentf" user-emacs-directory))
  (setq recentf-max-menu-items 10)
  (setq recentf-max-saved-items 200)
  (setq recentf-show-file-shortcuts-flag nil)
  :config
  (recentf-mode 1))
#+end_src
*** Minibuffer
#+begin_src emacs-lisp
(use-package savehist
  :init
  (setq savehist-file (expand-file-name "savehist" user-emacs-directory))
  (setq history-length 1000)
  (setq savehist-save-minibuffer-history t)
  :config
  (savehist-mode 1))
#+end_src
*** Point
Remember where point is in a file.
#+begin_src emacs-lisp
(use-package saveplace
  :init
  (setq save-place-file (expand-file-name "saveplace" user-emacs-directory))
  :config
  (save-place-mode 1))
#+end_src
*** Backups
#+begin_src emacs-lisp
(use-package emacs
  :custom
  (backup-directory-alist '(("." . "~/.emacs.d/backups")))
  (version-control t)
  (delete-old-versions t)
  (kept-new-versions 6)
  (kept-old-versions 2)
  (create-lockfiles nil))
#+end_src
** Local variables
#+begin_src emacs-lisp
(use-package files
  :custom
  <<files-custom>>
  )
#+end_src

[[info:emacs#File Variables][File Variables]] are useful to ensure same behaviour in some files with different emacs configurations or to change behaviour from the default for one file.
Some settings could be harmful to emacs and the underlying system. Therefore many settings have to be declared as safe before using them.
#+begin_src emacs-lisp :tangle no :noweb-ref files-custom
(safe-local-variable-values
 '((whitespace-style face trailing space-before-tab indentation empty space-after-tab newline-mark)
   (whitespace-style face trailing space-before-tab indentation empty space-after-tab)
   (eval set-window-buffer nil (current-buffer))
   (eval add-hook 'before-save-hook (lambda nil (fpi/tangle-async)) nil t)
   (org-attach-preferred-new-method . dir)
   (org-attach-use-inheritance . t)
   (right-margin-width . 2)
   (left-margin-width . 2)
   (line-spacing . 0.2)
   (after-save-hook org-babel-tangle)
   (header-line-format . " ")
   (after-save-hook . (org-babel-tangle))
   <<safe-local-variable-values>>
))
#+end_src
** Personal keymap

Unfortunately =C-c [a-z]= is not always a safe place for user-defined
key bindings. I use a special keymap to aggregate common functions. I
rebind the =C-z= binding for this.

Here is a helper macro to define keys including keymap prompts as described [[https://www.olivertaylor.net/emacs/keymap-prompt.html][here]]. This macro has a signature very similar to the regular ~define-key~ function.
#+begin_src emacs-lisp
(defmacro fpi/define-key (map key func &optional desc)
  "Define KEY in MAP with FUNC. Optionally provide DESC."
  (if desc
      `(define-key ,map ,key (cons ,desc ,func))
    `(define-key ,map ,key ,func)))
#+end_src

*** Toggle map to toggle common options
This was inspired from [[http://endlessparentheses.com/the-toggle-map-and-wizardry.html][this post]] and I bind it to a key on my personal keymap.
#+BEGIN_SRC emacs-lisp :results silent
(define-prefix-command 'fpi/toggle-map nil "Toggle")
(fpi/define-key fpi/toggle-map "c" #'column-number-mode "Column")
;;(define-key fpi/toggle-map "d" #'toggle-debug-on-error)
(fpi/define-key fpi/toggle-map "f" #'auto-fill-mode "Fill")
(fpi/define-key fpi/toggle-map "l" #'scroll-lock-mode "Lock scrolling")
(fpi/define-key fpi/toggle-map "s" #'flyspell-mode "Spelling")
(fpi/define-key fpi/toggle-map "t" #'toggle-truncate-lines "Truncate lines")
(fpi/define-key fpi/toggle-map "q" #'toggle-debug-on-quit "Quit trigger debug")
(fpi/define-key fpi/toggle-map "r" #'dired-toggle-read-only "Read only")
(autoload 'dired-toggle-read-only "dired" nil t )
(fpi/define-key fpi/toggle-map "v" #'visible-mode "Visible")
(fpi/define-key fpi/toggle-map "w" #'whitespace-mode "Whitespace")
(fpi/define-key fpi/toggle-map "W" #'whitespace-toggle-options "Whitespace Options")
#+END_SRC
*** fpi-map
#+BEGIN_SRC emacs-lisp :noweb yes
(define-prefix-command 'fpi-map nil "fpi-map")
(unbind-key (kbd "C-z"))
(global-set-key (kbd "C-z") 'fpi-map)

(fpi/define-key fpi-map (kbd "a") #'org-agenda-show-agenda-and-todo "Agenda")
(fpi/define-key fpi-map (kbd "b") #'bury-buffer "Bury")
(fpi/define-key fpi-map (kbd "c") #'compile "Compile")
;;(define-key fpi-map (kbd "u") 'multiple-cursors-hydra/body)
(fpi/define-key fpi-map (kbd "h") #'dfeich/context-hydra-launcher "Hydra")
;; (define-key fpi-map (kbd "m") 'notmuch)
(fpi/define-key fpi-map (kbd "t") #'fpi/toggle-map "Toggle")
(fpi/define-key fpi-map (kbd "n") #'sauron-toggle-hide-show "Notifications")
(fpi/define-key fpi-map (kbd "j") (lambda () (interactive) (find-file org-journal-file)) "Journal")

<<fpi-bindings>>
#+END_SRC
** Base commands (simple.el)
#+begin_src emacs-lisp
(use-package simple
  :delight (visual-line-mode)
  :config
  (defun zap-up-to-char (arg char)
    "Kill up to and excluding ARGth occurrence of CHAR.
Case is ignored if `case-fold-search' is non-nil in the current buffer.
Goes backward if ARG is negative; error if CHAR not found."
    (interactive (list (prefix-numeric-value current-prefix-arg)
                       (read-char "Zap to char: " t)))
    ;; Avoid "obsolete" warnings for translation-table-for-input.
    (with-no-warnings
      (if (char-table-p translation-table-for-input)
          (setq char (or (aref translation-table-for-input char) char))))
    (kill-region (point) (progn
                           (search-forward (char-to-string char) nil nil arg)
                           (if (>= arg 0)
                               (backward-char)
                             (forward-char))
                           (point))))
  <<simple-config>>
  :bind (:map global-map
              ("M-z" . zap-up-to-char)
              <<simple-bindings>>
              ))
#+end_src
Use a hard ~keyboard-quit~. This is from Jeff Norden ([[https://lists.gnu.org/archive/html/emacs-devel/2020-07/msg00326.html][Message on emacs-devel]]).
#+begin_src emacs-lisp :tangle no :noweb-ref simple-config
(defun keyboard-quit-strong ()
  "Run `keyboard-quit' to return emacs to a more responsive state.
If repeated twice in a row, run `top-level' instead, to also exit
any recursive editing levels."
  (interactive)
  (when (eq last-command 'keyboard-quit-strong)
    (setq this-command 'top-level) ;dis-arm a 3rd C-g
    (ding)
    (top-level))
  ;; Not reached after `top-level'. (A rare behavior in lisp.)
  (keyboard-quit))
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref simple-bindings
("C-g" . keyboard-quit-strong)
#+end_src
* Selection and search methods
** Completion frameworks
Having used ido, ivy, icicles and helm in the past, I'm trying to
settle for something simple and go back to ido. The settings below
are for now mostly copied from [[https://gitlab.com/protesilaos/dotemacs/][Protesilaos Stavrou]].
*** Minibuffer settings
#+begin_src emacs-lisp
(use-package minibuffer
  :config

  ;; Super-powerful completion style for out-of-order groups of matches
  ;; using a comprehensive set of matching styles.
  (use-package orderless
    :straight t
    :config
    (setq orderless-regexp-separator "[/\s_-]+")
    (setq orderless-matching-styles
          '(orderless-flex
            orderless-strict-leading-initialism
            orderless-regexp
            orderless-prefixes
            orderless-literal))

    (defun prot/orderless-literal-dispatcher (pattern _index _total)
      (when (string-suffix-p "=" pattern)
        `(orderless-literal . ,(substring pattern 0 -1))))

    (defun prot/orderless-initialism-dispatcher (pattern _index _total)
      (when (string-suffix-p "," pattern)
        `(orderless-strict-leading-initialism . ,(substring pattern 0 -1))))

    (setq orderless-style-dispatchers '(prot/orderless-literal-dispatcher
                                        prot/orderless-initialism-dispatcher))
    :bind (:map minibuffer-local-completion-map
                ("SPC" . nil)         ; space should never complete
                ("?" . nil)))         ; valid regexp character

  (setq completion-styles
        '(orderless partial-completion))
  (setq completion-category-defaults nil)
  (setq completion-cycle-threshold 3)
  (setq completion-flex-nospace nil)
  (setq completion-pcm-complete-word-inserts-delimiters t)
  (setq completion-pcm-word-delimiters "-_./:| ")
  (setq completion-show-help t)
  (setq completion-ignore-case t)
  (setq read-buffer-completion-ignore-case t)
  (setq read-file-name-completion-ignore-case t)
  (setq completions-format 'vertical)   ; *Completions* buffer
  (setq enable-recursive-minibuffers t)
  (setq read-answer-short t)
  (setq resize-mini-windows t)

  (file-name-shadow-mode 1)
  (minibuffer-depth-indicate-mode 1)
  (minibuffer-electric-default-mode 1)

  (defun prot/focus-minibuffer ()
    "Focus the active minibuffer.

Bind this to `completion-list-mode-map' to M-v to easily jump
between the list of candidates present in the \\*Completions\\*
buffer and the minibuffer (because by default M-v switches to the
completions if invoked from inside the minibuffer."
    (interactive)
    (let ((mini (active-minibuffer-window)))
      (when mini
        (select-window mini))))

  (defun prot/focus-minibuffer-or-completions ()
    "Focus the active minibuffer or the \\*Completions\\*.

If both the minibuffer and the Completions are present, this
command will first move per invocation to the former, then the
latter, and then continue to switch between the two.

The continuous switch is essentially the same as running
`prot/focus-minibuffer' and `switch-to-completions' in
succession."
    (interactive)
    (let* ((mini (active-minibuffer-window))
           ;; This could be hardened a bit, but I am okay with it.
           (completions (or (get-buffer-window "*Completions*")
                            (get-buffer-window "*Embark Live Occur*"))))
      (cond ((and mini
                  (not (minibufferp)))
             (select-window mini nil))
            ((and completions
                  (not (eq (selected-window)
                           completions)))
             (select-window completions nil)))))

  ;; Technically, this is not specific to the minibuffer, but I define
  ;; it here so that you can see how it is also used from inside the
  ;; "Completions" buffer
  (defun prot/describe-symbol-at-point (&optional arg)
    "Get help (documentation) for the symbol at point.

With a prefix argument, switch to the *Help* window.  If that is
already focused, switch to the most recently used window
instead."
    (interactive "P")
    (let ((symbol (symbol-at-point)))
      (when symbol
        (describe-symbol symbol)))
    (when arg
      (let ((help (get-buffer-window "*Help*")))
        (when help
          (if (not (eq (selected-window) help))
              (select-window help)
            (select-window (get-mru-window)))))))

  ;; This will be deprecated in favour of the `embark' package
  (defun prot/completions-kill-save-symbol ()
    "Add symbol-at-point to the kill ring.

Intended for use in the \\*Completions\\* buffer.  Bind this to a
key in `completion-list-mode-map'."
    (interactive)
    (kill-new (thing-at-point 'symbol)))


;;;; DEPRECATED in favour of the `embark' package (see further below),
;;;; which implements the same functionality in a more efficient way.
;;  (defun prot/complete-kill-or-insert-candidate (&optional arg)
;;     "Place the matching candidate to the top of the `kill-ring'.
;; This will keep the minibuffer session active.
;;
;; With \\[universal-argument] insert the candidate in the most
;; recently used buffer, while keeping focus on the minibuffer.
;;
;; With \\[universal-argument] \\[universal-argument] insert the
;; candidate and immediately exit all recursive editing levels and
;; active minibuffers.
;;
;; Bind this function in `icomplete-minibuffer-map'."
;;     (interactive "*P")
;;     (let ((candidate (car completion-all-sorted-completions)))
;;       (when (and (minibufferp)
;;                  (or (bound-and-true-p icomplete-mode)
;;                      (bound-and-true-p live-completions-mode))) ; see next section
;;         (cond ((eq arg nil)
;;                (kill-new candidate))
;;               ((= (prefix-numeric-value arg) 4)
;;                (with-minibuffer-selected-window (insert candidate)))
;;               ((= (prefix-numeric-value arg) 16)
;;                (with-minibuffer-selected-window (insert candidate))
;;                (top-level))))))

  ;; Defines, among others, aliases for common actions to Super-KEY.
  ;; Normally these should go in individual package declarations, but
  ;; their grouping here makes things easier to understand.
  :bind (("s-f" . find-file)
         ("s-F" . find-file-other-window)
         ("s-d" . dired)
         ("s-D" . dired-other-window)
         ("s-b" . switch-to-buffer)
         ("s-B" . switch-to-buffer-other-window)
         ("s-h" . prot/describe-symbol-at-point)
         ("s-H" . (lambda ()
                    (interactive)
                    (prot/describe-symbol-at-point '(4))))
         ("s-v" . prot/focus-minibuffer-or-completions)
         :map minibuffer-local-completion-map
         ("<return>" . minibuffer-force-complete-and-exit)
         ("C-j" . exit-minibuffer)
         ;;;; DEPRECATED in favour of the `embark' package
         ;; ("M-o w" . prot/complete-kill-or-insert-candidate)
         ;; ("M-o i" . (lambda ()
         ;;              (interactive)
         ;;              (prot/complete-kill-or-insert-candidate '(4))))
         ;; ("M-o j" . (lambda ()
         ;;              (interactive)
         ;;              (prot/complete-kill-or-insert-candidate '(16))))
         :map completion-list-mode-map
         ("h" . prot/describe-symbol-at-point)
         ("w" . prot/completions-kill-save-symbol)
         ("n" . next-line)
         ("p" . previous-line)
         ("f" . next-completion)
         ("b" . previous-completion)
         ("M-v" . prot/focus-minibuffer)))
#+end_src
*** Icomplete
#+begin_src emacs-lisp
(use-package icomplete
  :demand
  :after minibuffer                     ; Read that section as well
  :config
  (setq icomplete-delay-completions-threshold 100)
  (setq icomplete-max-delay-chars 2)
  (setq icomplete-compute-delay 0.2)
  (setq icomplete-show-matches-on-no-input t)
  (setq icomplete-hide-common-prefix nil)
  (setq icomplete-prospects-height 1)
  ;; (setq icomplete-separator " Â· ")
  ;; (setq icomplete-separator " â”‚ ")
  ;; (setq icomplete-separator " â”† ")
  ;; (setq icomplete-separator " Â¦ ")
  (setq icomplete-separator (propertize " â”† " 'face 'shadow))
  (setq icomplete-with-completion-tables t)
  (setq icomplete-in-buffer t)
  (setq icomplete-tidy-shadowed-file-names nil)

  (fido-mode -1)                        ; Emacs 27.1
  (icomplete-mode 1)

  (defun prot/icomplete-minibuffer-truncate ()
    "Truncate minibuffer lines in `icomplete-mode'.
  This should only affect the horizontal layout and is meant to
  enforce `icomplete-prospects-height' being set to 1.

  Hook it to `icomplete-minibuffer-setup-hook'."
    (when (and (minibufferp)
               (bound-and-true-p icomplete-mode))
      (setq truncate-lines t)))

  ;; Note that the the syntax for `use-package' hooks is controlled by
  ;; the `use-package-hook-name-suffix' variable.  The "-hook" suffix is
  ;; not an error of mine.
  :hook (icomplete-minibuffer-setup-hook . prot/icomplete-minibuffer-truncate)
  :bind (:map icomplete-minibuffer-map
              ("<tab>" . icomplete-force-complete)
              ("<return>" . icomplete-force-complete-and-exit) ; exit with completion
              ("C-j" . exit-minibuffer) ; force input unconditionally
              ("C-n" . icomplete-forward-completions)
              ("<right>" . icomplete-forward-completions)
              ("<down>" . icomplete-forward-completions)
              ("C-p" . icomplete-backward-completions)
              ("<left>" . icomplete-backward-completions)
              ("<up>" . icomplete-backward-completions)
              ;; The following command is from Emacs 27.1
              ("<C-backspace>" . icomplete-fido-backward-updir)))
#+end_src
*** Icomplete-vertical
#+begin_src emacs-lisp
(use-package icomplete-vertical
  :straight t
  :demand
  :after (minibuffer icomplete) ; do not forget to check those as well
  :config
  (setq icomplete-vertical-prospects-height (/ (frame-height) 6))
  (icomplete-vertical-mode -1)

  (defun prot/kill-ring-yank-complete ()
    "Insert the selected `kill-ring' item directly at point.
When region is active, `delete-region'.

Sorting of the `kill-ring' is disabled.  Items appear as they
normally would when calling `yank' followed by `yank-pop'."
    (interactive)
    (let ((kills                    ; do not sort items
           (lambda (string pred action)
             (if (eq action 'metadata)
                 '(metadata (display-sort-function . identity)
                            (cycle-sort-function . identity))
               (complete-with-action
                action kill-ring string pred)))))
      (icomplete-vertical-do
          (:separator 'dotted-line :height (/ (frame-height) 4))
        (when (use-region-p)
          (delete-region (region-beginning) (region-end)))
        (insert
         (completing-read "Yank from kill ring: " kills nil t)))))

  :bind (("s-y" . prot/kill-ring-yank-complete)
         :map icomplete-minibuffer-map
         ("C-v" . icomplete-vertical-toggle)))
#+end_src
*** Ido
:PROPERTIES:
:header-args:emacs-lisp: :tangle no
:END:
#+BEGIN_SRC emacs-lisp
(use-package ido
  :init
  (setq ido-everywhere t)
  (setq ido-enable-flex-matching t)
  (setq ido-enable-regexp nil)
  (setq ido-enable-prefix nil)
  (setq ido-all-frames nil)
  (setq ido-buffer-disable-smart-matches t)
  (setq ido-completion-buffer "*Ido Completions*")
  (setq ido-completion-buffer-all-completions nil)
  (setq ido-confirm-unique-completion nil)
  (setq ido-create-new-buffer 'prompt)
  (setq ido-default-buffer-method 'selected-window)
  (setq ido-default-file-method 'selected-window)
  (setq ido-enable-last-directory-history t)
  (setq ido-use-filename-at-point nil)
  (setq ido-use-url-at-point nil)
  (setq ido-use-virtual-buffers t)
  (setq ido-use-faces t)
  (setq ido-max-window-height 1)
  (setq ido-decorations
                '(" "
                  "   "
                  " | "
                  " | â€¦"
                  "["
                  "]"
                  " [No match]"
                  " [Matched]"
                  " [Not readable]"
                  " [Too big]"
                  " [Confirm]"
                  " "
                  " "))
  (setq ido-auto-merge-work-directories-length -1)
  :config
  (ido-mode 1)
  :hook
  (minibuffer-setup . (lambda ()
                                                  (visual-line-mode 1)
                                                  (setq-local truncate-lines nil)
                                                  (setq-local resize-mini-windows nil)
                                                  (setq-local max-mini-window-height 1))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
(use-package ido-completing-read+
  :straight t
  :after ido
  :config
  (ido-ubiquitous-mode 1))
#+END_SRC
*** amx
Ido completion for =M-x=.
#+BEGIN_SRC emacs-lisp :tangle no
(use-package amx
  :straight t
  :after (ido ido-completing-read+)
  :init
  (setq amx-backend 'ido)
  (setq amx-save-file "~/.emacs.d/amx-items")
  (setq amx-history-length 10)
  (setq amx-show-key-bindings nil)
  :config
  (amx-mode 1))
#+END_SRC
** isearch enhancements

Once again this is mostly taken from [[https://gitlab.com/protesilaos/dotemacs/][Protesilaos Stavrou]].

#+BEGIN_SRC emacs-lisp
(use-package isearch
  :init
  (setq search-whitespace-regexp ".*")
  ;; Or use the following for non-greedy matches
  ;; (setq search-whitespace-regexp ".*?")
  (setq isearch-lax-whitespace t)
  (setq isearch-regexp-lax-whitespace nil)
  :config
  (defun prot/isearch-mark-and-exit ()
        "Marks the current search string.  Can be used as a building
block for a more complex chain, such as to kill a region, or
place multiple cursors."
        (interactive)
        (push-mark isearch-other-end t 'activate)
        (setq deactivate-mark nil)
        (isearch-done))

  (defun stribb/isearch-region (&optional not-regexp no-recursive-edit)
        "If a region is active, make this the isearch default search
pattern."
        (interactive "P\np")
        (when (use-region-p)
          (let ((search (buffer-substring-no-properties
                                         (region-beginning)
                                         (region-end))))
                (message "stribb/ir: %s %d %d" search (region-beginning) (region-end))
                (setq deactivate-mark t)
                (isearch-yank-string search))))
  (advice-add 'isearch-forward-regexp :after 'stribb/isearch-region)
  (advice-add 'isearch-forward :after 'stribb/isearch-region)
  (advice-add 'isearch-backward-regexp :after 'stribb/isearch-region)
  (advice-add 'isearch-backward :after 'stribb/isearch-region)

  (defun contrib/isearchp-remove-failed-part-or-last-char ()
        "Remove failed part of search string, or last char if successful.
Do nothing if search string is empty to start with."
        (interactive)
        (if (equal isearch-string "")
                (isearch-update)
          (if isearch-success
                  (isearch-delete-char)
                (while (isearch-fail-pos) (isearch-pop-state)))
          (isearch-update)))

  (defun contrib/isearch-done-opposite-end (&optional nopush edit)
        "End current search in the opposite side of the match.
Particularly useful when the match does not fall within the
confines of word boundaries (e.g. multiple words)."
        (interactive)
        (funcall #'isearch-done nopush edit)
        (when isearch-other-end (goto-char isearch-other-end)))

  :bind (:map isearch-mode-map
              ("C-SPC" . prot/isearch-mark-and-exit)
              ("DEL" . contrib/isearchp-remove-failed-part-or-last-char)
              ("<C-return>" . contrib/isearch-done-opposite-end)))
#+END_SRC
* Directory, project, buffer, window management
** Dired
*** Base settings
- Always do recursive copies and deletions.
- Be smart about searching file names or the whole buffer.
- Use the system trash for now.
- Customize dired output switches.
- Dont try to be smart about rename and copy target locations when
  having two open dired buffers. Setting the target to the other
  directory is just as easy using =M-n= twice.
- Hide details by default. =(= to toggle.
- Highlight current line.
- Let the relevant =find= commands use case-insensitive names.
- Enable asynchronous mode for copying/renaming.
#+BEGIN_SRC emacs-lisp
(use-package dired
  :custom
  (dired-recursive-copies 'always)
  (dired-recursive-deletes 'always)
  (dired-isearch-filenames 'dwim)
  (delete-by-moving-to-trash t)
  (dired-listing-switches "-AFlh --group-directories-first")
  (dired-dwim-target nil)
  :hook
  (dired-mode . dired-hide-details-mode)
  (dired-mode . hl-line-mode)
  (dired-mode . auto-revert-mode)
  :bind (:map dired-mode-map
              <<dired-bindings>>
              ))

(use-package find-dired
  :after dired
  :custom
  (find-ls-option ;; applies to `find-name-dired'
   '("-ls" . "-AFlv --group-directories-first"))
  (find-name-arg "-iname"))

(use-package async
  :straight t)

(use-package dired-async
  :after (dired async)
  :config
  (dired-async-mode 1))
#+END_SRC
*** Narrowing
#+BEGIN_SRC emacs-lisp
(use-package dired-narrow
  :straight t
  :after dired
  :bind (:map dired-mode-map
                 ("SPC" . dired-narrow-regexp)))
#+END_SRC
*** wdired
Start with =C-x C-q=.
- Allow to change permissions.
- Interpret forward slash in renamed files as new subdirectory to
  create.

#+BEGIN_SRC emacs-lisp
(use-package wdired
  :after dired
  :init
  (setq wdired-allow-to-change-permissions t)
  (setq wdired-create-parent-directories t))
#+END_SRC
*** peep-dired (file previews including images)
By default, dired does not show previews of files, while =image-dired=
is intended for a different purpose. We just want to toggle the
behaviour while inside a regular dired buffer.

#+BEGIN_SRC emacs-lisp
(use-package peep-dired
  :straight t
  :after dired
  :bind (:map dired-mode-map
              ("P" . peep-dired))
  :custom
  (peep-dired-cleanup-on-disable t)
  (peep-dired-ignored-extensions
   '("mkv" "webm" "mp4" "mp3" "ogg" "iso")))
#+END_SRC
*** dired git info
#+begin_src emacs-lisp
(use-package dired-git-info
  :straight t
  :bind (:map dired-mode-map
              (")" . dired-git-info-mode)))
#+end_src
*** dired-x
Some additional features that are shipped with Emacs.

#+BEGIN_SRC emacs-lisp
(use-package dired-x
  :after dired
  :bind (("C-x C-j" . dired-jump)
         ("C-x 4 C-j" . dired-jump-other-window))
  :hook
  (dired-mode . (lambda ()
                  (setq dired-clean-confirm-killing-deleted-buffers t))))
#+END_SRC
*** dired-subtree
+ The tab key will expand or contract the subdirectory at point.
+ =C-TAB= will behave just like org-mode handles its headings: hit it
  once to expand a subdir at point, twice to do it recursively, thrice
  to contract the tree.
+ I also have Shift-TAB for contracting the subtree /when the point is
  inside of it/.

At any rate, this does not override the action of inserting a
subdirectory listing in the current dired buffer (with =i= over the
target dir).

#+BEGIN_SRC emacs-lisp
(use-package dired-subtree
  :straight t
  :after dired
  :bind (:map dired-mode-map
                          ("<tab>" . dired-subtree-toggle)
                          ("<C-tab>" . dired-subtree-cycle)
                          ("<S-iso-lefttab>" . dired-subtree-remove)))
#+END_SRC
*** dired-sidebar
Open a small sidebar window showing the current directory.
#+BEGIN_SRC emacs-lisp
(use-package dired-sidebar
  :bind (("C-x C-n" . dired-sidebar-toggle-sidebar))
  :straight t
  :commands (dired-sidebar-toggle-sidebar)
  :hook
  (dired-sidebar-mode . (lambda ()
                                                           (unless (file-remote-p default-directory)
                                                                 (auto-revert-mode))))
  :config
  ;; (setq dired-sidebar-theme 'vscode)
  (setq dired-sidebar-use-term-integration t))
#+END_SRC

*** dired-du
Recursive directory sizes. Toggle with =C-x M-r=. This will take a
while for directories with lots of nested files.
#+BEGIN_SRC emacs-lisp
(use-package dired-du
  :straight t
  :config (setq dired-du-size-format 't))
#+END_SRC
** Tramp
Set Tramp to prefer the path settings in =~/.profile= over the value
of src_shell{getconf "PATH"}. See [[elisp:(describe-variable
'tramp-remote-path)]] for more info.
#+begin_src emacs-lisp
(use-package tramp
  :config
  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
#+end_src
** Git
*** Git annex
There are some great resources on [[https://git-annex.branchable.com/][git-annex]] integration in emacs in [[https://github.com/mm--/dot-emacs/blob/master/jmm-emacs.org][Josh's config]]. Most of my configuration is copied from there.
Or use magit-annex instead?
#+begin_src emacs-lisp :noweb-ref straight-recipe-overrides :tangle no :eval never
(git-annex :type git :flavor melpa :host github :repo "jwiegley/git-annex-el")
#+end_src
#+begin_src emacs-lisp
(use-package git-annex
  :straight (:host github :repo "fpiper/git-annex-el" :branch "master")
  :config
  <<git-annex-config>>
  :after dired
  :bind
  (:map git-annex-dired-map
        <<git-annex-dired-bindings>>)
  (:map dired-mode-map
        <<git-annex-dired-map-bindings>>
        )
  )
#+end_src
**** Actions to lock/unlock files
#+begin_src emacs-lisp :tangle no :noweb-ref git-annex-dired-bindings
("l" . git-annex-dired-lock-files)
("u" . git-annex-dired-unlock-files)
#+end_src
=git-annex.el= defines a handy macro to define generic =git-annex= CLI calls.
#+begin_src emacs-lisp :tangle no :noweb-ref git-annex-config
(git-annex-dired-do-to-files "lock" "Annex: locked %d file(s)")
(git-annex-dired-do-to-files "unlock" "Annex: unlocked %d file(s)")
#+end_src
**** Fix faces
=git-annex.el= kinda clobbers ~dired-marked-face~ and ~dired-flagged-face~. This fixes that.
#+begin_src emacs-lisp :tangle no :noweb-ref git-annex-config
(progn
  (add-to-list 'dired-font-lock-keywords
	       (list "^[*].+ -> .*\\.git/annex/"
		     '("\\(.+\\)\\( -> .+\\)" (dired-move-to-filename) nil
		       (1 dired-marked-face)
		       (2 git-annex-dired-annexed-invisible))))
  (add-to-list 'dired-font-lock-keywords
	       (list "^[D].+ -> .*\\.git/annex/"
		     '("\\(.+\\)\\( -> .+\\)" (dired-move-to-filename) nil
		       (1 dired-flagged-face)
		       (2 git-annex-dired-annexed-invisible)))))
#+end_src
**** Make it easy to add metadata tags in git-annex
#+begin_src emacs-lisp :tangle no :noweb-ref git-annex-dired-bindings
("t" . jmm/dired-git-annex-tag)
#+end_src
Git-annex has a pretty cool ability to tag files and filter directory views based on metadata. It's kind of a pain to tag files, though, so here's a function that adds some autocompletion to tagging files.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref git-annex-config
(defvar-local jmm/git-annex-directory-tags nil
  "Current git-annex tags set in the directory, as a list.")

(defun jmm/dired-git-annex-current-tags (file-list &optional intersection)
  "Get current git-annex tag for each file in FILE-LIST. With
  optional argument INTERSECTION, only show tags all files share in common."
  (let* ((metadata (with-output-to-string
		    (with-current-buffer
			standard-output
		      (apply #'process-file "git" nil t nil "annex" "metadata" "--json" file-list))))
	 (json-array-type 'list)
	 (jsonout (-map 'json-read-from-string (split-string metadata "\n" t))))
    (-reduce (if intersection '-intersection '-union) (--map (cdr (assoc 'tag (cdr (assoc 'fields it)))) jsonout))))

(defun jmm/dired-git-annex-tag (file-list tags &optional arg)
  "Add git-annex TAGS to each file in FILE-LIST.
Used as an interactive command, prompt for a list of tags for all
files, showing the current tags all files currently have in common."
  (interactive
   (let* ((files (dired-get-marked-files t current-prefix-arg))
	  (shared-tags (jmm/dired-git-annex-current-tags files t))
	  ;; Cache directory tags
	  (current-tags (or jmm/git-annex-directory-tags
			    (setq jmm/git-annex-directory-tags
				  (or (jmm/dired-git-annex-current-tags '("--all")) '("")))))
	  (crm-separator " ")
	  (crm-local-completion-map
	   (let ((map (make-sparse-keymap)))
	     (set-keymap-parent map crm-local-completion-map)
	     (define-key map " " 'self-insert-command)
	     map))
	  (tags (completing-read-multiple
		 "Tags: " (--map (concat it crm-separator) current-tags)
		 nil nil
		 (when shared-tags (mapconcat 'identity shared-tags " ")))))
     (setq jmm/git-annex-directory-tags (-union tags jmm/git-annex-directory-tags))
     (list files tags current-prefix-arg)))
  (let ((args (cl-loop for x in tags
		       append (list "-t" x))))
    (-each file-list
      (lambda (file)
	(apply #'call-process "git" nil nil nil "annex" "metadata" (append args (list file)))))
    (message (format "Tagged %d file(s)" (length file-list)))))
#+END_SRC
**** Mark unavailable files
#+begin_src emacs-lisp :tangle no :noweb-ref git-annex-dired-bindings
("*")
("* a" . jmm/dired-mark-git-annex-available-files)
("* u" . jmm/dired-mark-git-annex-unavailable-files)
#+end_src

When you use this in combination with ~dired-do-kill-lines~ (by default bound to ~k~), it's easy to hide files that aren't present in the current annex repository.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref git-annex-config
(defun jmm/dired-mark-git-annex-unavailable-files ()
  "Mark git-annex files that are not present."
  (interactive)
  (dired-mark-if
   (and (looking-at-p ".* -> \\(.*\\.git/annex/.+\\)")
	(not (file-exists-p (file-truename (dired-get-filename t)))))
   "unavailable file"))

(defun jmm/dired-mark-git-annex-available-files ()
  "Mark git-annex files that are present."
  (interactive)
  (dired-mark-if
   (and (looking-at-p ".* -> \\(.*\\.git/annex/.+\\)")
	(file-exists-p (file-truename (dired-get-filename t))))
   "available file"))
#+END_SRC
**** Mark git-annex files with git-annex-matching-options
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref git-annex-dired-map-bindings
("% a" . jmm/dired-mark-files-git-annex-matching)
#+END_SRC

This command makes it easy to mark dired files using ~git-annex-matching-options~.

For instance, you could find files that are in a certain remote using ~--in=remote~ or mark/unmark files that have a certain tag using ~--metadata tag=sometag~.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref git-annex-config
(defun jmm/dired-mark-files-git-annex-matching (matchingoptions &optional marker-char)
  "Mark all files that match git annex's MATCHINGOPTIONS for use in later commands.
A prefix argument means to unmark them instead.
`.' and `..' are never marked."
  (interactive
   (list (read-string (concat (if current-prefix-arg "Unmark" "Mark")
                              " files matching (git annex match expression): ")
                      nil 'jmm-dired-annex-matchingoptions-history)
	 (if current-prefix-arg ?\040)))
  (let ((dired-marker-char (or marker-char dired-marker-char)))
    (dired-mark-if
     (and (not (looking-at-p dired-re-dot))
	  (not (eolp))			; empty line
	  (let ((fn (dired-get-filename nil t)))
	    (when (and fn (not (file-directory-p fn)))
	      (message "Checking %s" fn)
	      (s-present? (shell-command-to-string
			   (mapconcat
			    #'identity
			    (list "git annex find" matchingoptions (shell-quote-argument fn))
			    " "))))))
     "matching file")))
#+END_SRC
**** Real file size
:PROPERTIES:
:header-args:emacs-lisp: :tangle no
:END:
Dired by default only shows the symlink file size. While it can be told to dereference symbolic links with the =-L= flag this only works on annexed files if they are present on the current machine.
Settings this flag causes more problems than it solves. Instead Josh has derived the functions below to determine the file size. I do not use them for now, but copied them here for future reference/usage.
***** Get git-annex file sizes
#+begin_src emacs-lisp :tangle no :noweb-ref git-annex-dired-bindings
("s" . jmm/dired-git-annex-print-human-file-size)
#+end_src
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref git-annex-config
(defun jmm/git-annex-file-target (filename)
  "If FILENAME is a git annex file, return its symlink target."
  (-when-let (symname (and filename
			   (file-symlink-p filename)))
    (when (string-match-p ".*\\.git/annex/.+" symname)
      symname)))

(defun jmm/dired-git-annex-file-target ()
  "If the dired file at point is a git annex file, return its symlink target."
  (jmm/git-annex-file-target (dired-get-filename nil t)))

(defun jmm/git-annex-file-size (filename)
  "Try to determine the size of the git annex file FILENAME."
  (-when-let (target (jmm/git-annex-file-target filename))
    (or (save-match-data
	  (when (string-match "SHA256E-s\\([0-9]+\\)--" target)
	    (string-to-number (match-string 1 target))))
	(-some-> (expand-file-name target (file-name-directory filename))
		 file-attributes
		 file-attribute-size))))

(defun jmm/dired-git-annex-print-human-file-size ()
  "Try to print the human readable file size of the dired git-annex file at point."
  (interactive)
  (let* ((filename (dired-get-filename nil t))
	 (string-file (file-name-nondirectory filename)))
    (-if-let (filesize (-some-> (jmm/git-annex-file-size filename)
				file-size-human-readable))
	(message "%s - %s" filesize string-file)
      (message "Can't determine git annex file size of %s" string-file))))
#+END_SRC
***** Show git-annex file sizes in dired
#+begin_src emacs-lisp :tangle no :noweb-ref git-annex-dired-bindings
("S" . jmm/dired-git-annex-add-real-file-sizes)
#+end_src

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref git-annex-config
;; Based off of `dired--align-all-files'
(defun jmm/dired-git-annex-add-real-file-sizes ()
  "Go through all the git-annex files in dired, replace the
symlink file size with the real file size, then try to align
everything."
  (interactive)
  (require 'dired-aux)
  (let ((regexp directory-listing-before-filename-regexp))
    (save-excursion
      (goto-char (point-min))
      (dired-goto-next-file)
      (while (or (dired-move-to-filename)
		 (progn (save-restriction
			  (narrow-to-region (dired-subdir-min) (dired-subdir-max))
			  (dired--align-all-files))
			(dired-next-subdir 1 t)
			(dired-goto-next-file)
			(dired-move-to-filename)))
	(let ((inhibit-read-only t))
	  (when (and (jmm/dired-git-annex-file-target)
		     (re-search-backward regexp (line-beginning-position) t))
	    (goto-char (match-beginning 0))
	    (-when-let (newsize (-some-> (jmm/git-annex-file-size (dired-get-filename nil t))
					 file-size-human-readable))
	      (search-backward-regexp "[[:space:]]" nil t)
	      (when (re-search-forward "[[:space:]]+\\([^[:space:]]+\\)[[:space:]]" nil t)
		(goto-char (match-beginning 1))
		(delete-region (point) (match-end 1))
		(insert-and-inherit newsize))))
	  (forward-line))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
;; (add-hook 'dired-mode-hook #'jmm/dired-git-annex-add-real-file-sizes)
;; (add-hook 'dired-after-readin-hook #'jmm/dired-git-annex-add-real-file-sizes)
#+END_SRC
***** Sort dired by file size
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref git-annex-config
(defun jmm/dired-dir-files-beginning ()
  "First point where there's a filename on the line. Beginning of line."
  (save-excursion
    (goto-char (dired-subdir-min))
    (dired-goto-next-file)
    (beginning-of-line)
    (point)))

(defun jmm/dired-dir-files-end ()
  "Last point where there's a filename. End of line."
  (save-excursion
    (goto-char (dired-subdir-max))
    (while (not (dired-get-filename nil t))
      (dired-previous-line nil))
    (end-of-line)
    (point)))

(defun jmm/dired-file-size ()
  "Return the file size of a file at point (for sorting). Takes
into account git-annex files."
  (let* ((filename (dired-get-filename nil t))
	 (string-file (file-name-nondirectory filename)))
    (or (jmm/git-annex-file-size filename)
	(file-attribute-size (file-attributes filename)))))

;; TODO: Should just try to directly use the field listed.
(defun jmm/dired-sort-size (&optional ascending)
  "Sort some dired lines by size (consider annex sizes).
With optional argument ASCENDING, sort by ascending file size. (I
like going the other way around usually.)"
  (interactive "P")
  (let (buffer-read-only
	(beg (jmm/dired-dir-files-beginning))
	(end (jmm/dired-dir-files-end)))
    (save-excursion
      (save-restriction
	(narrow-to-region beg end)
	(goto-char (point-min))
	(sort-subr (not ascending)
		   'forward-line 'end-of-line
		   #'jmm/dired-file-size nil)))))
#+END_SRC
**** Browsing URLs for git-annex files
#+begin_src emacs-lisp :tangle no :noweb-ref git-annex-dired-bindings
("b" . jmm/git-annex-browse-url)
#+end_src
#+BEGIN_SRC emacs-lisp
;; TODO: Process multiple files at once?
(defun jmm/git-annex-whereis-info (filename)
  "Get information about where a git-annex file exists.
Returns a parsed json list from whereis."
  (let* ((json-array-type 'list)
	 (whereisdata (shell-command-to-string
		       (mapconcat
			#'identity
			(list "git annex whereis --json" (shell-quote-argument filename))
			" "))))
    (when (s-present? whereisdata)
      (json-read-from-string whereisdata))))

(defun jmm/git-annex-urls (filename)
  "Get the git-annex web urls for FILENAME."
  (-some->> (jmm/git-annex-whereis-info filename)
	    (assoc-default 'whereis)
	    (-mapcat (lambda (x) (assoc-default 'urls x)))
	    (-map (lambda (s) (s-chop-prefix "yt:" s)))))

(defun jmm/git-annex-browse-url ()
  "Browse the first git-annex web urls for file at point."
  (interactive)
  (let* ((filename (dired-get-filename nil t))
	 (filestr (file-name-nondirectory filename)))
    (-if-let (url (car (jmm/git-annex-urls filename)))
	(progn
	  (message "Opening url: %s" url)
	  (jmm/org-open-link-alternate-browser #'browse-url url))
      (user-error "No url found for %s" filestr))))
#+END_SRC
**** Eshell helper functions
Helper functions to open dired view from eshell or list =git-annex= files which match a search.
#+BEGIN_SRC emacs-lisp
(defun jmm/git-annex-find-files (&rest args)
  "Generate a list of git annex files that match ARGS.
For example, ARGS could be \"--in=here\""
  (-remove #'s-blank?
	   (s-split "\0"
		    (shell-command-to-string (mapconcat #'identity
							(append '("git annex find --print0") args)
							" ")))))
(defun eshell/dga (&rest args)
  "Show a `dired' buffer of git annex files that match ARGS.
For example, ARGS could be \"--in=here\""
  (dired (cons "." (apply #'jmm/git-annex-find-files args))))

(defun eshell/gaf (&rest args)
  "Return a list of git annex files that match ARGS.
For example, ARGS could be \"--in=here\""
  (apply #'jmm/git-annex-find-files args))
#+END_SRC
*** Magit
#+BEGIN_SRC emacs-lisp
(use-package magit
  :straight t
  :custom (magit-completing-read-function 'magit-ido-completing-read)
  :init (global-magit-file-mode))
#+END_SRC

The following package is configured in accordance with the guidelines
provided by this article on [[https://chris.beams.io/posts/git-commit/][writing a Git commit message]].

#+BEGIN_SRC emacs-lisp
(use-package git-commit
  :after magit
  :custom
  (git-commit-fill-column 72)
  (git-commit-summary-max-length 50)
  (git-commit-known-pseudo-headers
   '("Signed-off-by"
         "Acked-by"
         "Modified-by"
         "Cc"
         "Suggested-by"
         "Reported-by"
         "Tested-by"
         "Reviewed-by"))
  (git-commit-style-convention-checks
   '(non-empty-second-line
         overlong-summary-line)))
#+END_SRC

Only highlight the changes within a line, not the whole line.

#+BEGIN_SRC emacs-lisp
(use-package magit-diff
  :after magit
  :custom
  (magit-diff-refine-hunk 'all))
#+END_SRC
**** Forge
#+begin_src emacs-lisp
(use-package forge
  :after magit
  :straight t
  :config
  <<forge-config>>)
#+end_src
Non-standard forges need to be added to ~forge-alist~ manually.
#+begin_src emacs-lisp :tangle no :noweb-ref forge-config
(append forge-alist private/magit-forges)
#+end_src
**** gitflow
Add support for [[https://nvie.com/posts/a-successful-git-branching-model/][gitflow]].
#+begin_src emacs-lisp
(use-package magit-gitflow
   :straight t
   :hook (magit-mode . turn-on-magit-gitflow))
#+end_src
*** git-identity
Found it in this [[https://www.manueluberti.eu/emacs/2020/03/30/lockdown-beam-git-identity/][blog post]] from Manuel Uberti. An easy way to handle multiple git identities.

#+begin_src emacs-lisp
(use-package git-identity
  :straight t
  :custom
  (git-identity-verify t)
  (git-identity-list private/git-identity-list)
  :bind (:map magit-status-mode-map ("I" . git-identity-info)))
(use-package git-identity-magit
  :config (git-identity-magit-mode 1))
#+end_src
*** diff-hl
Indicates changed lines in the left fringe. The Hydra can be used to
navigate and revert hunks directly from the buffer. Use =g= to open
=magit-status=. I also bind this hydra to =g= in my personal keymap.

#+begin_src emacs-lisp
(use-package diff-hl
  :straight t
  :init (global-diff-hl-mode 1)
  :config (defhydra hydra-diff-hl (:body-pre (diff-hl-mode 1)
                                             :hint nil)
  "
  Diff-hl:
    _n_: next hunk        _s_tage hunk     _g_: Magit status
    _p_: previous hunk    _r_evert hunk    _b_: Magit blame popup
    ^ ^                   _P_opup hunk     ^ ^
    _a_: first hunk       ^ ^              _q_uit
    _e_: last hunk        _A_mend mode     _Q_uit and deactivate git-gutter
  "
  ("n" diff-hl-next-hunk)
  ("p" diff-hl-previous-hunk)
  ("a" (progn (goto-char (point-min))
              (diff-hl-next-hunk)))
  ("e" (progn (goto-char (point-max))
              (diff-hl-previous-hunk)))
  ("s" git-gutter:stage-hunk)
  ("r" diff-hl-revert-hunk)
  ("P" diff-hl-diff-goto-hunk)
  ("A" diff-hl-amend-mode)
  ("g" magit-status :color blue)
  ("b" magit-blame :color blue)
  ("q" nil :color blue)
  ("Q" (diff-hl-mode -1)
       :color blue))
)
#+end_src

#+begin_src emacs-lisp :noweb-ref fpi-bindings :tangle no
(fpi/define-key fpi-map "g" #'hydra-diff-hl/body "Git diff")
#+end_src
*** git-auto-commit
Mode to automatically commit on file save. Ensure that automatic
pushing is always turned off. To enable this with [[info:emacs#File Variables][File Variables]] set
some safe local variable values.
#+begin_src emacs-lisp
(use-package git-auto-commit-mode
  :delight
  :straight t
  :custom
  (gac-automatically-push-p nil))
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref safe-local-variable-values
(git-auto-commit-mode . t)
(gac-debounce-interval . 600)
#+end_src
** Projects
*** project.el
#+begin_src emacs-lisp
(use-package project
  :init
  (defun fpi/project-magit ()
    (interactive)
    (magit-status (project-root (project-current t))))
  :custom
  (project-switch-commands
   '((?f "Find file" project-find-file)
     (?g "Find regexp" project-find-regexp)
     (?d "Dired" project-dired)
     (?m "Magit" fpi/project-magit)
     (?v "VC-Dir" project-vc-dir)
     (?e "Eshell" project-eshell))))
#+end_src
*** Projectile
Projectile should be fully replaceable with =project.el=. Though some packages may still use projectile as dependency..
#+BEGIN_SRC emacs-lisp :tangle no
(use-package projectile
  :straight t
  :delight '(:eval (concat " " (projectile-project-name)))
  :init
  (setq projectile-project-search-path '("~/git/projects/"))
  (setq projectile-indexing-method 'alien)
  (setq projectile-enable-caching t)
  (setq projectile-completion-system 'ido)
  (setq projectile-file-exists-local-cache-expire (* 5 60))
  :config
  ;; (projectile-mode 1)
  :bind (("C-c p" . projectile-command-map)))
#+END_SRC
** Working with buffers

This renames buffers with the same name and uniqifies them using angled
brackets containing their path.
#+BEGIN_SRC emacs-lisp
(use-package uniquify
  :custom
  (uniquify-buffer-name-style 'forward)
  (uniquify-strip-common-suffix t)
  (uniquify-after-kill-buffer-p t))
#+END_SRC
#+begin_src emacs-lisp
(use-package autorevert
  :delight (auto-revert-mode))
#+end_src
*** ibuffer

#+BEGIN_SRC emacs-lisp
(use-package ibuffer
  :custom
  (ibuffer-display-summary nil)
  (ibuffer-use-other-window nil)
  (ibuffer-auto-mode -1)
  :hook
  (ibuffer-mode . ibuffer-auto-mode))
#+END_SRC

Sort buffers in project groups using projectile.
#+BEGIN_SRC emacs-lisp :tangle no
(use-package ibuffer-projectile
  :straight t
  :after (ibuffer projectile)
  :hook
  (ibuffer-mode . (lambda ()
                           (ibuffer-projectile-set-filter-groups)
                           (unless (eq ibuffer-sorting-mode 'recency)
                                 (ibuffer-do-sort-by-recency)))))
#+END_SRC
=ibuffer-projectile= updates can be fairly slow. =ibuffer-vc= provides
better performance.
#+begin_src emacs-lisp
(use-package ibuffer-vc
  :straight t
  :custom
  (ibuffer-formats
       '((mark modified read-only vc-status-mini " "
               (name 18 18 :left :elide)
               " "
               (size 9 -1 :right)
               " "
               (mode 16 16 :left :elide)
               " "
               (vc-status 16 16 :left)
               " "
               vc-relative-file)))
  :hook
 (ibuffer . (lambda ()
              (ibuffer-vc-set-filter-groups-by-vc-root)
              (unless (eq ibuffer-sorting-mode 'alphabetic)
                (ibuffer-do-sort-by-alphabetic)))))
#+end_src
** Window configuration
:PROPERTIES:
:ID:       99f1af26-1383-43c1-8408-9a13c495925e
:END:
=fit-window-to-buffer= automatically shrinks the current buffer based
on the amount of displayed text.
#+begin_src emacs-lisp
(use-package emacs ;; windows.el does not (provide 'windows)
  :init
  <<window>>
  :custom
  (fit-window-to-buffer-horizontally t)
  :config
  (defun split-window-left (&optional size)
    (interactive "P")
    (split-window-right size)
    (other-window 1))
  (defun split-window-above (&optional size)
    (interactive "P")
    (split-window-below size)
    (other-window 1))
  :bind
  (:map global-map ("C-x C-3" . split-window-left))
  (:map global-map ("C-x C-2" . split-window-above))
  <<window-bindings>>
  )
#+end_src
*** Window rules
#+begin_src emacs-lisp :noweb-ref window
(setq display-buffer-alist
      '(("\\*\\(Backtrace\\|Warnings\\|Compile-Log\\|Messages\\)\\*"
         (display-buffer-in-side-window)
         (window-height . 0.16)
         (side . top)
         (slot . 0)
         (window-parameters . ((no-other-window t))))
        (".*\\*Completions.*"
         (display-buffer-in-side-window)
         (window-height . 0.16)
         (side . bottom)
         (slot . 0))
        ("\\*Help.*"
         (display-buffer-in-side-window)
         (window-width . 0.2)
         (side . left)
         (slot . 0)
         (window-parameters . ((no-other-window . t)
                               (mode-line-format . (" "
                                                    mode-line-buffer-identification)))))
        ))
#+end_src
*** window-numbering
This is a nice package for easy window focus switching. I prefer it
over =windmove=, as it does not interfere with org keybindings.
#+begin_src emacs-lisp
(use-package window-numbering
  :straight t
  :config (window-numbering-mode 1))
#+end_src
*** Winner-mode
#+begin_src emacs-lisp
(use-package winner
  :hook (after-init . winner-mode)
  :hydra (winner-hydra
          (global-map "C-c" :color red)
          "Winner undo/redo"
          ("<left>" winner-undo "undo")
          ("<right>" winner-redo "redo"))
  :bind (:map winner-mode-map
              ("C-c <left>" . winner-hydra/winner-undo)
              ("C-c <right>" . winner-hydra/winner-redo)))
#+end_src
** File encryption
=epa= handles en-/decryption with =gnupg=. Setting ~'loopback~ pinentry mode will ask for the key passphrase in the emacs minibuffer. For this the =pinentry= package is needed, as well as setting =allow-emacs-pinentry= in the =gnupg= configuration.

#+begin_src emacs-lisp
(use-package epa
  :custom (epa-pinentry-mode (if (equal (fpi/current-device-info :os) 'win10)
                                 nil
                               'loopback)))
(use-package pinentry
  :straight t
  :config (pinentry-start)
  :after epa)
#+end_src
* Applications and utilities
** Calendar
Some basic calendar options for date format und location to provide
correct sunrise/-set times.
#+begin_src emacs-lisp
(use-package calendar
  :custom
  (calendar-date-style 'european)
  (calendar-latitude 52.3667)
  (calendar-longitude 9.7167))
#+end_src

Set the holidays to consider. I only use german and christian
holidays. Note the =:init= keyword. The individual holiday lists have
to be set before =holidays= is loaded and ~calendar-holidays~ is
initialized.
#+begin_src emacs-lisp
(use-package holidays
  :init
  (setq holiday-bahai-holidays nil
        holiday-christian-holidays
        (quote
         ((holiday-float 12 0 -4 "1. Advent" 24)
          (holiday-float 12 0 -3 "2. Advent" 24)
          (holiday-float 12 0 -2 "3. Advent" 24)
          (holiday-float 12 0 -1 "4. Advent" 24)
          (holiday-fixed 12 25 "1. Weihnachtstag")
          (holiday-fixed 12 26 "2. Weihnachtstag")
          (holiday-fixed 1 6 "Heilige Drei KÃ¶nige")
          (holiday-easter-etc -48 "Rosenmontag")
          (holiday-easter-etc -2 "Karfreitag")
          (holiday-easter-etc 0 "Ostersonntag")
          (holiday-easter-etc 1 "Ostermontag")
          (holiday-easter-etc 39 "Christi Himmelfahrt")
          (holiday-easter-etc 49 "Pfingstsonntag")
          (holiday-easter-etc 50 "Pfingstmontag")
          (holiday-easter-etc 60 "Fronleichnam")
          (holiday-fixed 8 15 "Mariae Himmelfahrt")
          (holiday-fixed 11 1 "Allerheiligen")
          (holiday-float 11 0 1 "Totensonntag" 20)))
        holiday-general-holidays
        (quote
         ((holiday-fixed 1 1 "Neujahr")
          (holiday-fixed 2 14 "Valentinstag")
          (holiday-fixed 5 1 "1. Mai")
          (holiday-float 5 0 2 "Muttertag")
          (holiday-fixed 10 3 "Tag der Deutschen Einheit")))
        holiday-hebrew-holidays nil
        holiday-islamic-holidays nil
        holiday-oriental-holidays nil))
(use-package solar
  :custom
  (solar-n-hemi-seasons '("FrÃ¼hlingsanfang" "Sommeranfang" "Herbstanfang" "Winteranfang")))
#+end_src
** PDFs
=PDF-Tools= provides better rendering than =DocView=, which is only
png based. It also provides pdf syncing with a tex source. To use this
make sure to compile the tex document with the option ~--synctex=1~.

#+BEGIN_SRC emacs-lisp
(use-package pdf-tools
  :straight t
  :config
  (setq pdf-info-epdfinfo-program (concat user-emacs-directory "epdfinfo"))
  (pdf-tools-install))
#+END_SRC

Add support for pdf annotations. Rebind ~pdf-annot-minor-mode-map~ to
an easier prefix and undefine the bindings of ~image-mode~ for this
prefix. For now they are unbound globally as I never use them. It
would be better to unbind them only when in ~pdf-view-mode~.
#+BEGIN_SRC emacs-lisp
(use-package image-mode
  :config
  (define-key image-mode-map "a+" nil)
  (define-key image-mode-map "a-" nil)
  (define-key image-mode-map "a0" nil)
  (define-key image-mode-map "ar" nil))

(use-package pdf-annot
  :init (setq pdf-annot-minor-mode-map-prefix "a")
  :bind (:map pdf-annot-minor-mode-map ("a d" . pdf-annot-delete)))
#+END_SRC

Advice =load-theme= to update the colors for =pdf-view-midnight-mode=
after the theme changes.
#+NAME: theme-dependent-vars
#+begin_src emacs-lisp :tangle no
(defun update-pdf-view-midnight-color (&rest arg)
              (customize-save-variable
               'pdf-view-midnight-colors
               `(,(face-attribute 'default :foreground) . ,(face-attribute 'default :background))))
(advice-add 'load-theme :after
            #'update-pdf-view-midnight-color)
#+end_src

** Latex
#+begin_src emacs-lisp
(use-package tex-site
  :straight auctex)
#+end_src

=cdlatex= depends on =texmath.el=. The docstring of =cdlatex= says
=texmath= is supposed to be part of Emacs. However my installation
does not have it. So =auctex= has to deliver this dependency instead.
#+begin_src emacs-lisp
(use-package cdlatex
  :straight t
  :custom
  (cdlatex-env-alist
    (list '("equation*" "\\begin{equation*}\nAUTOLABEL\n?\n\\end{equation*}" nil)
          '("tikzpicture" "\\begin{tikzpicture}\nAUTOLABEL\n?\n\\end{tikzpicture}" nil)
          '("circuitikz" "\\begin{circuitikz}\nAUTOLABEL\n?\n\\end{circuitikz}" nil))))
#+end_src
** Programming languages
*** Utilities
Various utilities which ease programming in some languages.
#+begin_src emacs-lisp
(use-package yasnippet
  :straight t)
(use-package yasnippet-snippets
  :straight t)
(use-package company
  :straight t)
#+end_src

#+begin_src emacs-lisp
(use-package lsp-mode
  :straight t)
#+end_src
*** Emacs lisp
Remap ~eval-last-sexp~ to a pretty print version. Then you can use =C-0 C-x C-e= to insert the values of the last sexp. Use ~pp-macroexpand-last-sexp~ to print a macro expanded version of the last sexp (but not eval it).
#+begin_src emacs-lisp
(global-set-key [remap eval-last-sexp] 'pp-eval-last-sexp)
#+end_src

=Speed of thought= makes writing lisp so easy. No more snippets
needed.
#+begin_src emacs-lisp
(use-package sotlisp
  :straight t
  :init
  (add-hook 'emacs-lisp-mode-hook 'speed-of-thought-mode))
#+end_src
=Eldoc= displays information on variables and functions in the echo
area.
#+begin_src emacs-lisp
(use-package eldoc
  :delight)
#+end_src
*** Matlab
#+begin_src emacs-lisp
(use-package matlab
  :straight matlab-mode
  :config
  (unbind-key "M-s" matlab-mode-map))
#+end_src
*** Rust
#+begin_src emacs-lisp
(use-package rustic
  :straight t
  :after org)
#+end_src
** CAD
[[https://www.openscad.org/][OpenSCAD]] is a programmable CAD Modeller.
#+begin_src emacs-lisp
(use-package scad-mode
  :straight t)
#+end_src
** Calc
#+begin_src emacs-lisp
(use-package calc
  :custom
  (calc-lu-field-reference "1 V")
  (calc-lu-power-reference "1 mW"))
#+end_src
** Org mode
Org is the mode you never need to leave, if you do not want to. My org
TODO and clocking setup is largely inspired by [[http://doc.rix.si/cce/cce-org.html][Ryan Rix's]] and [[http://doc.norang.ca/org-mode.html][Bernt
Hansen's]] configs.
- Scale latex previews :: The default is just a little bit too
     small
- org-plus-contrib :: Install the =org-plus-contrib= package which
     contains many extra org-modules.
- Startup indented :: Enable =org-indent-mode= in every org file. This
     shows the content of headings indented to the headings level, but
     does not actually insert whitespace at the start of the line.
- Enable Speed commands :: With the custom function speed commands are
     enabled on any star of an headline.
- Set fast tag selection :: By defining default tags they can be set
     just with one key press, similar to TODO states.
- Code blocks :: Open code blocks in the current window and use native
                 settings for the code blocks.
- Custom link abbrevs :: Define any expansion and use them as normal
     org links like [[ddg:emacs]].
- Babel languages :: Enable more languages to use in org-babel blocks.
- Youtube links :: See [[http://endlessparentheses.com/embedding-youtube-videos-with-org-mode-links.html][this blog post]] for more info.
- Ellipsis :: I currently use =" ï„‡"= and previously used ="âš¡âš¡âš¡"=.
- Drawer for Notes :: Notes go into the =NOTES= drawer. Clocking
  times should stay separate in the =LOGBOOK= drawer.
- Track state changes :: Notes when an entry is switched to done when
  the deadline or scheduled time change
- TODO Keywords :: Set my todo keywords, enable fast selection & some
  custom faces for the todo keywords
- Change todo state on clock-in :: Switch entries automatically from
  NEXT to INPROGRESS
- Align tags left :: Fixes problems with line breaking on small
  window width.

I use a org version with some custom patches. Rather than using something like =el-patch=, I host my version on github for now and update it every so often.
#+begin_src emacs-lisp :noweb-ref org-recipe :tangle no
(org :host github :repo "fpiper/org-mode" :branch "develop"
     ;;:local-repo "org" :files (:defaults "contrib/lisp/*.el")
     )
#+end_src

#+begin_src emacs-lisp
(use-package org
  :straight
  <<org-recipe>>
  :delight (org-cdlatex-mode)
  :bind
  (("C-c c" . org-capture)
   ("C-c a" . org-agenda)
   ("C-c l" . org-store-link))
  :custom
  (org-catch-invisible-edits 'smart)
  (org-agenda-diary-file "~/sync/diary.org")
  (org-use-speed-commands (lambda () (and (looking-at org-outline-regexp) (looking-back "^\**"))))
  (org-pretty-entities t)
  (org-fast-tag-selection-single-key t)
  (org-link-abbrev-alist
   '(("google"    . "http://www.google.com/search?q=")
     ("ddg"       . "https://duckduckgo.com/?q=")
     ("gmap"      . "http://maps.google.com/maps?q=%s")
     ("omap"      . "http://nominatim.openstreetmap.org/search?q=%s&polygon=1")))
  (org-ellipsis " ï„‡")
  (org-outline-path-complete-in-steps nil)
  (org-log-into-drawer "NOTES")
  (org-tags-column 0)
  (org-tags-exclude-from-inheritance '(
   <<org-custom-no-inheritance-tags>>
   ))
  <<org-custom>>
  :hook
  <<org-hook>>
  :config
  (add-to-list 'org-structure-template-alist (cons "f" "figure"))
  ;; (add-to-list 'org-tags-exclude-from-inheritance "MARKED")
  <<org-config>>
  )

<<org-crypt>>
<<tangle-hook>>
<<org-crypt-tangle-setup>>
#+end_src
#+begin_src emacs-lisp
(use-package org-indent
  :delight
  :custom
  (org-startup-indented t)
  <<org-indent-custom>>
  )
#+end_src
#+begin_src emacs-lisp
(use-package ob-spice
  :straight (:host github :repo "fpiper/ob-spice"
                   :branch "master"))
#+end_src

#+begin_src emacs-lisp
(use-package ob-spectre
  :load-path "~/git/projects/ob-spectre")
#+end_src
#+begin_src emacs-lisp
(use-package ob
  :config  (org-babel-do-load-languages
            'org-babel-load-languages
            '((ruby . t)
              (python . t)
              ;;(ipython . t)
              (emacs-lisp . t)
              (octave . t)
              (gnuplot . t)
              (dot . t)
              (spice . t)
              (spectre . t)
              (C . t)
              (calc . t)
              (latex . t)
              (matlab . t)
              (shell . t)
              (lua . t)
              (org . t)
              (js . t)
              (ditaa . t)
              (plantuml . t)
              ;; (hvm . t)
              (ledger . t)))
  :hook <<ob-hooks>>)
#+end_src
#+BEGIN_SRC emacs-lisp
(use-package org-noter
  :straight t
  :bind (:map org-mode-map ("C-c o" . org-noter))
  :custom (org-noter-default-notes-file-names '("notes.org"))
  )
#+END_SRC

#+begin_src emacs-lisp
(use-package org-pdftools
  :straight t
  :hook (org-load . org-pdftools-setup-link))
(use-package org-id
  :custom
  (org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id)
  <<org-id-custom>>)
#+end_src
I prefer to use timestamp based ID's as they are
#+begin_src emacs-lisp :tangle no :noweb-ref org-id-custom
(org-id-method 'ts)
(org-id-ts-format "%FT%T%z.%6N")
#+end_src

#+begin_src emacs-lisp
(use-package org-src
  :custom
  (org-src-window-setup 'other-window)
  (org-src-fontify-natively t)
  (org-src-tab-acts-natively t)
  (org-edit-src-content-indentation 0))
#+end_src

#+begin_src emacs-lisp
(defun fpi/collect-org-directories-recursively (dir)
  "Return list of all directories which contain .org files of DIR and its subdirectories"
  (delete-dups (mapcar 'file-name-directory (directory-files-recursively dir "\.org$"))))
(use-package org-agenda
  :custom
  (org-agenda-files (fpi/collect-org-directories-recursively "~/sync"))
  (org-deadline-warning-days 14)
  (org-agenda-start-on-weekday nil)
  (org-agenda-span 'day)
  (org-agenda-start-day "+0d")
  (org-agenda-include-diary nil)
  (org-agenda-sticky t)
  (org-agenda-todo-ignore-deadlines 'near) ;; or future?
  (org-agenda-todo-ignore-scheduled 'future)
  (org-agenda-skip-deadline-prewarning-if-scheduled t)
  (org-agenda-tags-todo-honor-ignore-options t)
  (org-agenda-todo-list-sublevels t) ;; nil to exclude sublevels of todos
  (org-agenda-sorting-strategy '((agenda habit-down time-up priority-down category-keep)
                                 (todo priority-down category-keep)
                                 (tags priority-down category-keep)
                                 (search category-keep)))
  (org-agenda-skip-scheduled-if-done t)
  (org-agenda-dim-blocked-tasks t)
  (org-sort-agenda-notime-is-late t)
  (org-agenda-scheduled-leaders '(" âž«" "âž« ")) ;; alternatives if font supports them: ðŸ‘‰ðŸ–ðŸ•£ðŸ•£
  ;; See emacs.christianbaeuerlein.com/my-org-config.html
  (org-agenda-block-separator 9472)
  (org-agenda-custom-commands
   `(
     <<org-agenda-custom-commands>>
     ))
  <<org-agenda-custom>>
  :config
  <<org-agenda-config>>
  )
#+end_src

#+begin_src emacs-lisp
(use-package ob-core
  :custom
  (org-confirm-babel-evaluate nil))
(use-package org-screenshot)
(use-package org-collector)
(use-package ox)
(use-package ol-notmuch)
(use-package org-habit)
#+end_src

#+begin_src emacs-lisp
(use-package org-inlinetask)
#+end_src
=org-bullets= provides better headline bullets.
Here is a list of nice ones: â—‰, â—‹, â–º, â€¢. The default ones are ~'("â—‰" "â—‹" "âœ¸" "âœ¿")~.
#+begin_src emacs-lisp
(use-package org-bullets
  :straight t
  :custom (org-bullets-bullet-list '(" "))
  :config (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+end_src
#+begin_src emacs-lisp
(use-package org-num
  :delight
  :after org
  :hook (org-mode . org-num-mode))
#+end_src
*** Org & Latex
:PROPERTIES:
:header-args:emacs-lisp: :tangle no
:END:

#+begin_src emacs-lisp :noweb-ref org-custom
(org-format-latex-header
"\\documentclass{standalone}
\\usepackage[usenames]{color}
[PACKAGES]
[DEFAULT-PACKAGES]
\\pagestyle{empty}             % do not remove")
#+end_src

#+begin_src emacs-lisp :noweb-ref org-custom
(org-latex-default-packages-alist
 '(("mathletters" "ucs")
   ("AUTO" "inputenc" t ("pdflatex")) 
   ("T1" "fontenc" t ("pdflatex"))
   ("" "graphicx" t)
   ("" "grffile" t)
   ("" "longtable" nil)
   ("" "wrapfig" nil)
   ("" "rotating" nil)
   ("normalem" "ulem" t)
   ("" "amsmath" t)
   ("" "textcomp" t)
   ("" "amssymb" t)
   ("" "capt-of" nil)
   ("" "hyperref" nil)))
#+end_src

#+begin_src emacs-lisp :noweb-ref org-config
(add-to-list 'org-latex-packages-alist '("" "siunitx"))
(add-to-list 'org-latex-packages-alist '("" "personal"))
(add-to-list 'org-latex-packages-alist '("" "svg"))
(add-to-list 'org-latex-packages-alist '("" "tikz"))
(add-to-list 'org-latex-packages-alist '("" "circuitikz"))
#+end_src

#+begin_src emacs-lisp :noweb-ref org-hook
(org-mode . turn-on-org-cdlatex)
#+end_src
*** Org Exporter =ox=
#+begin_src emacs-lisp
(use-package ox
  :custom
  (org-export-with-broken-links 'match)
  (org-export-backends '(ascii beamer html icalendar latex man md odt org groff koma-letter)))
#+end_src
**** Latex & Beamer
#+begin_src emacs-lisp
(use-package ox-latex
  :custom
  (org-latex-compiler "lualatex")
  (org-latex-pdf-process
   '("latexmk -f -pdf -%latex -shell-escape -interaction=nonstopmode -output-directory=%o %f")))
#+end_src
Allow ~\framebreak{}~ by default, set a default theme and we also redefine the beamer latex class to use an aspect ratio of 16:9. The frame size will then be 160â€¯mm by 90â€¯mm.
#+begin_src emacs-lisp
(use-package ox-beamer
  :custom
  (org-beamer-frame-default-options "allowframebreaks")
  (org-beamer-theme "Hannover")
  :config
  (remove (assoc "beamer" org-latex-classes) org-latex-classes)
  (add-to-list 'org-latex-classes
	       '("beamer"
		 "\\documentclass[presentation,aspectratio=169]{beamer}"
		 ("\\section{%s}" . "\\section*{%s}")
		 ("\\subsection{%s}" . "\\subsection*{%s}")
		 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")))
  )
#+end_src
Latex preview
#+begin_src emacs-lisp :tangle no :noweb-rew org-custom
(org-preview-latex-default-process 'imagemagick)
(org-format-latex-options
 '(:foreground default :background default :scale 1.5 :html-foreground "Black" :html-background "Transparent" :html-scale 1.0 :matchers ("begin" "$1" "$" "$$" "\\(" "\\[")))
(org-preview-latex-process-alist
'(
(dvipng :programs ("latex" "dvipng") :description "dvi > png" :message "you need to install the programs: latex and dvipng." :image-input-type "dvi" :image-output-type "png" :image-size-adjust (1.0 . 1.0) :latex-compiler ("latex -interaction nonstopmode -output-directory %o %f") :image-converter ("dvipng -D %D -T tight -bg Transparent -o %O %f")) 
(dvisvgm :programs ("latex" "dvisvgm") :description "dvi > svg" :message "you need to install the programs: latex and dvisvgm." :image-input-type "dvi" :image-output-type "svg" :image-size-adjust (1.7 . 1.5) :latex-compiler ("latex -interaction nonstopmode -output-directory %o %f") :image-converter ("dvisvgm %f -n -b min -c %S -o %O")) 
(imagemagick :programs ("latex" "convert") :description "pdf > png" :message "you need to install the programs: latex and imagemagick." :image-input-type "pdf" :image-output-type "png" :image-size-adjust (1.0 . 1.0) :latex-compiler ("lualatex -interaction nonstopmode -output-directory %o %f") :image-converter ("convert -density %D -trim -antialias %f -quality 100 %O"))
(pdf2svg :programs ("lualatex" "pdf2svg") :description "pdf > svg" :message "" :image-input-type "pdf" :image-output-type "svg" :image-size-adjust (2.0 . 2.0) :latex-compiler ("lualatex -interaction nonstopmode -output-directory %o %f") :image-converter ("pdf2svg %f %O"))))
#+end_src
**** ox-reveal
#+BEGIN_SRC emacs-lisp
(use-package ox-reveal
  :straight t)
(use-package reveal)
(setq org-reveal-root "http://cdn.jsdelivr.net/reveal.js/3.0.0/")
#+END_SRC
*** Timekeeping & Clocking
- Remove clocks with zero time.
- Save a clocking history of the list 50 clocked items.
- Clock into the =LOGBOOK= drawer (as opposed to log entries going into ~org-log-into-drawer~)
#+begin_src emacs-lisp
(use-package org-clock
  :custom
  (org-clock-out-remove-zero-time-clocks t)
  (org-clock-persist 'history)
  (org-clock-history-length 50)
  (org-clock-into-drawer "LOGBOOK")
  :init
  (org-clock-persistence-insinuate)
  )
#+end_src
Even with the history clocking into the correct item is sometimes difficult. So why not clock in any refile target:
#+begin_src emacs-lisp
(defun fpi/org-clock-in-heading (&optional prompt)
  (interactive)
  (let* ((location (org-refile-get-location (or prompt "Clock in on")))
         (file (cadr location))
         (marker (car (last location))))
    (save-excursion
      (save-restriction
        (find-file file)
        (goto-char marker)
        (org-clock-in)
        (current-buffer)))))
#+end_src
**** Durations
#+begin_src emacs-lisp
(use-package org-duration
  :after org
  :custom
  (org-duration-format '(("h" . t) ("min" . t) (special . h:mm))))
#+end_src
*** Task organization
Much of my current task workflow is largely inspired by [[http://doc.rix.si/cce/cce-org.html][Ryan Rix's]] and [[http://doc.norang.ca/org-mode.html][Bernt
Hansen's]] configs.
**** =[WIP]= Task Setup
***** Todos
- WAITING tasks are waiting on the completion of other tasks
- NEXT tasks can be picked up
- INPROGRESS are current tasks with time clocked
- DONE are complete tasks
- ICEBOX tasks are on ice for whatever reason

TODO->DONE cycle is for habits.\\
Idle states cover things to do for time in between, checking the
inbox, reading news, â€¦

#+BEGIN_SRC dot :file /tmp/todo.png
digraph hierarch {
        node [shape=box]
        // Projects
        PLANNING -> READY -> ACTIVE -> DONE, ICEBOX
        // Tasks
        HOLD -> NEXT -> INPROGRESS -> DONE, ICEBOX
        NEXT -> ICEBOX, DONE
        NEXT -> WAITING -> NEXT
        INPROGRESS -> WAITING -> INPROGRESS

        IDLE -> IDLE
        TODO -> DONE -> TODO
        INPROGRESS -> REVIEW -> DONE

        { rank = source; PLANNING; HOLD }
        { rank = same; READY; NEXT; TODO; IDLE }
        { rank = same; ACTIVE; INPROGRESS }
        { rank = sink; ICEBOX; DONE }
}
#+END_SRC

#+RESULTS:
[[file:/tmp/todo.png]]

#+begin_src emacs-lisp :noweb-ref org-config :tangle no
(defvar org-task-keywords
  '("HOLD" "NEXT" "INPROGRESS" "REVIEW" "WAITING")
  "Org todo keywords to demark tasks")
(defvar org-project-keywords
  '("PLANNING" "READY" "ACTIVE")
  "Org todo keywords to demark projects")
#+end_src

#+begin_src emacs-lisp :noweb-ref org-custom :tangle no
(org-todo-keywords '((sequence "HOLD(h)" "NEXT(n)" "INPROGRESS(i!)" "WAITING(w@/!)" "REVIEW(r!)" "|" "ICEBOX(x@)" "DONE(d)") ;;todos
                     (sequence "PLANNING(p)" "READY(r)" "ACTIVE(a!)" "|" "ICEBOX(x@)" "DONE(d)") ;;projects
                     ;; (sequence "PHONE(P)" "MEETING(m)" "|" "CANCELED(c)" "DONE(d)")
                     (sequence "TODO(t)" "|" "DONE(d)")
                     (sequence "IDLE(b)" "|")))
(org-use-fast-todo-selection t)
(org-todo-keyword-faces
 '(("HOLD" :foreground "light gray" :weight bold)
   ("NEXT" :foreground "light blue" :weight bold)
   ("INPROGRESS" :foreground "burlywood" :weight bold)
   ("REVIEW" :foreground "light goldenrod" :weight bold)
   ("ACTIVE" :foreground "chocolate" :weight bold)
   ("DONE" :foreground "forest green" :weight bold)
   ("WAITING" :foreground "orange" :weight bold)
   ("ICEBOX" :foreground "orange" :weight normal)
   ;; ("CANCELLED" :foreground "forest green" :weight bold)
   ;; ("MEETING" :foreground "yellow3" :weight bold)
   ;; ("PHONE" :foreground "yellow3" :weight bold)
   ("IDLE" :foreground "magenta" :weight bold)))
#+end_src
****** Automatically do =NEXTâ†’INPROGRESS= / =READYâ†’ACTIVE=
Switch a todo entry from NEXT to INPROGRESS when clocking in.
#+begin_src emacs-lisp :tangle no :noweb-ref org-config
(defun bh/clock-in-to-inprogress (kw)
  "Switch a task from NEXT to INPROGRESS when clocking in.
Switch projects from READY to ACTIVE."
  (when (not (and (boundp 'org-capture-mode) org-capture-mode))
    (cond
     ((member (org-get-todo-state) (list "NEXT"))
      "INPROGRESS")
     ((member (org-get-todo-state) (list "READY"))
      "ACTIVE"))))
#+end_src
#+begin_src emacs-lisp :tangle no :noweb-ref org-custom
(org-clock-in-switch-to-state 'bh/clock-in-to-inprogress)
#+end_src
****** State changes
Track state changes to done & changes to schedules and deadlines.
#+begin_src emacs-lisp :tangle no :noweb-ref org-custom
(org-log-done 'time)
(org-log-redeadline 'time)
(org-log-reschedule 'time)
#+end_src
***** Tags
Inspired by [[https://bzg.fr/en/some-emacs-org-mode-features-you-may-not-know.html/][Bastien Guerry]], [[https://github.com/jwiegley/dot-emacs][John Wiegley]].
#+begin_src emacs-lisp :tangle no :noweb-ref org-custom
(org-tag-alist (quote (("HOT" . ?h)
                       (:startgroup) ;; Location 
                       ("@errand" . ?E) ("@office" . ?O) ("@home" . ?H)
                       (:endgroup)
                       (:startgrouptag) ;; context tags
                       ("net" . ?n) ("call" . ?c) ("reply" . ?R)
                       (:endgrouptag)
                       (:startgroup)
                       ("handson" . ?o) ;; For focused/active tasks
                       (:grouptags)
                       ;; ("code" . ?c) ("design" . ?d) ("review" . ?v)
                       (:endgroup)
                       (:startgroup)
                       ("handsoff" . ?f) ;; For listening/passive tasks
                       (:grouptags)
                       ("read" . ?r) ("watch" . ?w)
                       (:endgroup)
                       ("crypt" . ?E)
                       ("FLAGGED" . ??)
                       )))
#+end_src
Exclude =HOT= from inheritance
#+begin_src emacs-lisp :tangle no :noweb-ref org-custom-no-inheritance-tags
"HOT"
#+end_src
***** Creating projects
#+begin_src emacs-lisp
(defun fpi/make-parent-project ()
  (when (or (string-equal org-state "NEXT")
            (string-equal org-state "HOLD")
            (string-equal org-state "INPROGRESS")
            (string-equal org-state "WAITING"))
    ;; Activate parent
    (org-up-element)
    (let ((todo (org-entry-is-todo-p)))
      (when todo
        (org-todo "ACTIVE")
        ;; (end-of-line)
        ;; (insert " [0/0]")
        (org-update-statistics-cookies nil)
        ))
    ))
#+end_src
***** INPROGRESS Custom Agendas
- John Wiegley: Different background colors for different source files
****** General
- "h": Next action for hot projects
- Project Next actions agenda
- "P": All Projects
- "r": uncategorized items (CATEGORY="Inbox"&LEVEL=2)
- "w": waiting/delegated tasks (W-TODO="DONE"|TODO={WAITING\|DELEGATED})
- Unscheduled tasks (TODO<>""&TODO<>{DONE\|CANCELED\|NOTE\|PROJECT\|DEFERRED\|SOMEDAY})
- "c": Appointment calendar
****** Task-related agendas
Simple day agenda with =INPROGRESS= tasks
******* Hot Projects
#+begin_src emacs-lisp :tangle no :noweb-ref org-agenda-custom-commands
("h" "Current Hotlist" tags "TODO={NEXT\\|INPROGRESS}"
 ((org-agenda-overriding-header "Current Hotlist")
  (org-agenda-skip-function (function fpi/org-agenda-skip-all-not-hot))
  (org-agenda-sorting-strategy
   '(priority-down category-keep user-defined-down))
  (org-agenda-cmp-user-defined #'fpi/org-agenda-compare-hotness)
  (org-agenda-prefix-format "%-12:c %-45(fpi/org-breadcrumbs)")
  ;; (org-agenda-prefix-format " %-3i %-12:c%30b %s")
  ))
#+end_src
#+begin_src emacs-lisp :tangle no :noweb-ref org-agenda-config
(defun fpi/org-breadcrumbs ()
  "Return projects over current entry.

Similar to %b in `org-agenda-prefix-format'."
  (org-with-wide-buffer
   (let ((depth (fpi/org-project-depth 10))
         result)
     (while (< (length result) depth)
       (fpi/org-goto-parent-project 10)
       (add-to-list 'result
                    (org-trim
	             (org-link-display-format
	              (replace-regexp-in-string
	               "\\[[0-9]+%\\]\\|\\[[0-9]+/[0-9]+\\]" ""
                       (nth 4 (org-heading-components)) ;; get entry title
                       )))))
     (if result
         (reduce
          (lambda (a b) (format "%s/%s" a b))
          (mapcar (lambda (s) (format "%.12s" s)) result)
          )
       "")
     )))
(defun fpi/org-goto-parent-project (depth)
  "Goto first project over current entry."
  (when (fpi/parent-is-not-done-project-p)
    (org-up-heading-safe))
   (while (and (> depth 0)
               (not (fpi/is-not-done-project-p))
     (org-up-heading-safe))
   ))
(defun fpi/org-agenda-compare-hotness (a b)
  "Compare level of hot headlines over entries A and B."
  (let ((ha (fpi/org-agenda-hotness a))
        (hb (fpi/org-agenda-hotness b)))
    (cond
     ((> ha hb) +1)
     ((< ha hb) -1)
     (t nil))))
(defun fpi/org-agenda-hotness (&optional entry)
  "Return level of hot headlines over ENTRY."
  (org-agenda-with-point-at-orig-entry entry (fpi/org-hotness)))
(defun fpi/org-hotness ()
  "Return level of hot headlines over current entry."
  (let* ((tags (my-org-current-tags (fpi/org-project-depth 10)))
         (l1 (length tags))
         (l2 (length (remove "HOT" tags))))
    (- l1 l2)))
(defun fpi/org-agenda-skip-all-not-hot-and-active ()
  "Skip all not hot entries and not active entries."
  (when (not (and
         (member "HOT" (my-org-current-tags (fpi/org-project-depth 10)))
         (org-with-wide-buffer
          (fpi/org-goto-parent-project 10)
          (fpi/is-active-project-p))))
    (or (outline-next-heading)
        (goto-char (point-max)))))
(defun fpi/org-agenda-skip-all-not-hot ()
  "Skip all not hot entries."
  (when (not (member "HOT" (my-org-current-tags (fpi/org-project-depth 10))))
    (or (outline-next-heading)
        (goto-char (point-max)))))
(defun fpi/org-agenda-skip-all-project-tasks ()
  "Skip all entries which belong to a project."
  (when (fpi/is-part-of-project-p 10)
    (or (outline-next-heading)
        (goto-char (point-max)))))
(defun my-org-current-tags (depth)
  (save-excursion
    (ignore-errors
      (let (should-skip)
        (while (and (> depth 0)
                    (prog1
                        (setq depth (1- depth))
                      (not (org-up-element))))
          (if (looking-at "^\*+\\s-+")
              (setq should-skip (append should-skip (org-get-local-tags)))))
        should-skip))))
(defun fpi/org-project-depth (depth)
  "Return number of subheadings before reaching top project."
  (org-with-wide-buffer (fpi/org-goto-top-project depth)))
(defun fpi/org-goto-top-project (depth)
  "Go to the top project of heading under point"
  (save-restriction
    (widen)
    (let (top
          (count -1))
      (with-demoted-errors
          (while (and (> depth 1)
                      (not (equal top (point))))
            (setq depth (1- depth))
            (setq top (point))
            (fpi/org-goto-parent-project depth)
            (setq count (1+ count))))
      count)))
(defun fpi/is-part-of-project-p (depth)
  "Return t if any parent heading is a project."
  (< 0 (fpi/org-project-depth depth)))
(defun fpi/parent-is-not-done-project-p ()
  "Return t if parent heading is a not done project."
  (save-excursion
    (save-restriction
      (widen)
      (and (not (org-up-element))
           (fpi/is-not-done-project-p)))))
(defun fpi/is-not-done-project-p ()
  "Return t if current heading is a not done project."
  (save-restriction
    (widen)
    (let ((todo (org-get-todo-state)))
      (member todo org-project-keywords))))
(defun fpi/is-active-project-p ()
  "Return t if current heading is an active project."
  (save-restriction
    (widen)
    (equal "ACTIVE" (org-get-todo-state))))
#+end_src
To narrow the agenda to the currently selected project this function from [[https://github.com/mm--/dot-emacs/blob/master/jmm-org-config.org][Josh's emacs config]] is useful.
#+begin_src emacs-lisp :tangle no :noweb-ref org-agenda-config
(defun fpi/org-agenda-lock-to-parent-project ()
  "In the org mode agenda, lock the restriction to the current project."
  (interactive)
  (save-window-excursion
    (org-agenda-goto)
    (if (fpi/org-goto-top-project 10)
	(org-agenda-set-restriction-lock)
      (user-error "No parent project found.")))
  (org-agenda-redo-all))
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref org-agenda-custom-commands
("H" "Hot Projects" tags "HOT&TODO={PLANNING\\|READY\\|ACTIVE}"
 ((org-agenda-overriding-header "Hot Projects")))
("T" "Non-Hot Projects" tags "-HOT&TODO={PLANNING\\|READY\\|ACTIVE}"
 ((org-agenda-overriding-header "Non-Hot Projects")))
("P" "All Projects"
 ((tags "HOT&TODO={PLANNING\\|READY\\|ACTIVE}"
        ((org-agenda-overriding-header "Hot Projects")))
  (tags "-HOT&TODO={PLANNING\\|READY\\|ACTIVE}"
        ((org-agenda-overriding-header "Non-Hot Projects")))
  ))
#+end_src
Some tasks do not go into projects. Let's list only those.
#+begin_src emacs-lisp :tangle no :noweb-ref org-agenda-custom-commands
("g" "Non-Project (general) Tasks" tags "TODO={NEXT\\|INPROGRESS\\|REVIEW\\|WAITING}"
 ((org-agenda-overriding-header "Non-Project Tasks")
  (org-agenda-skip-function (function fpi/org-agenda-skip-all-project-tasks))))
#+end_src
******* 
#+begin_src emacs-lisp :tangle no :noweb-ref org-agenda-custom-commands
("n" "Project Next Actions" alltodo ""
 ((org-agenda-overriding-header "Current Hotlist")
  (org-agenda-skip-function
   (function fpi/org-agenda-skip-all-not-hot))))
#+end_src
#+begin_src emacs-lisp :tangle no :noweb-ref org-agenda-custom-commands-wiegley
("A" "Priority #A tasks" agenda ""
 ((org-agenda-ndays 1)
  (org-agenda-overriding-header "Today's priority #A tasks: ")
  (org-agenda-skip-function
   (quote
    (org-agenda-skip-entry-if
     (quote notregexp)
     "\\=.*\\[#A\\]")))))
("b" "Priority #A and #B tasks" agenda ""
 ((org-agenda-ndays 1)
  (org-agenda-overriding-header "Today's priority #A and #B tasks: ")
  (org-agenda-skip-function
   (quote
    (org-agenda-skip-entry-if
     (quote regexp)
     "\\=.*\\[#C\\]")))))
("r" "Uncategorized items" tags "CATEGORY=\"Inbox\"&LEVEL=2"
 ((org-agenda-overriding-header "Uncategorized items")))
("W" "Waiting/delegated tasks" tags "W-TODO=\"DONE\"|TODO={WAITING\\|DELEGATED}"
 ((org-agenda-overriding-header "Waiting/delegated tasks:")
  (org-agenda-skip-function
   (quote
    (org-agenda-skip-entry-if
     (quote scheduled))))
  (org-agenda-sorting-strategy
   (quote
    (todo-state-up priority-down category-up)))))
("D" "Deadlined tasks" tags "TODO<>\"\"&TODO<>{DONE\\|CANCELED\\|NOTE\\|PROJECT}"
 ((org-agenda-overriding-header "Deadlined tasks: ")
  (org-agenda-skip-function
   (quote
    (org-agenda-skip-entry-if
     (quote notdeadline))))
  (org-agenda-sorting-strategy
   (quote
    (category-up)))))
("S" "Scheduled tasks" tags "TODO<>\"\"&TODO<>{APPT\\|DONE\\|CANCELED\\|NOTE\\|PROJECT}&STYLE<>\"habit\""
 ((org-agenda-overriding-header "Scheduled tasks: ")
  (org-agenda-skip-function
   (quote
    (org-agenda-skip-entry-if
     (quote notscheduled))))
  (org-agenda-sorting-strategy
   (quote
    (category-up)))))
("d" "Unscheduled open source tasks (by date)" tags "TODO<>\"\"&TODO<>{DONE\\|CANCELED\\|NOTE\\|PROJECT}"
 ((org-agenda-overriding-header "Unscheduled Open Source tasks (by date): ")
  (org-agenda-skip-function
   (quote
    (org-agenda-skip-entry-if
     (quote scheduled)
     (quote deadline)
     (quote timestamp)
     (quote regexp)
     "\\* \\(DEFERRED\\|SOMEDAY\\)")))))
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref org-agenda-custom-commands
("d" "Day agenda"
    ((agenda "" ((org-agenda-span 'day)))
     (org-time-budgets-in-agenda-maybe)
     (tags-todo "/+INPROGRESS"
                ((org-agenda-overriding-header "Active Tasks")))))
#+end_src
Agenda with all open tasks
#+begin_src emacs-lisp :tangle no :noweb-ref org-agenda-custom-commands
("n" "Agenda and all TODOs"
 ((todo "INPROGRESS"
        ((org-agenda-overriding-header "Inprogress Tasks")))
  (agenda)
  (tags-todo "+soon+LEVEL=2"
             ((org-agenda-overriding-header "2nd Level /Soon/ Tasks")))
  (tags-todo "+soon"
             ((org-agenda-overriding-header "All /Soon/ Tasks")))
  (tags-todo "+shelve")
  (tags-todo "+habit")
  (todo "IDLE")
  (tags-todo "-habit-shelve-soon-idle")))
#+end_src
******* Fancy agenda to choose todays tasks
Based on https://github.com/psamim/dotfiles/blob/master/doom/config.el#L73.
#+begin_src emacs-lisp :tangle no :noweb-ref org-agenda-custom-commands
("o" "My Agenda"
 ((agenda "" ((org-agenda-block-separator ? )
              (org-agenda-overriding-header "\nâš¡ Deadlines:\nâŽºâŽºâŽºâŽºâŽºâŽºâŽºâŽºâŽº")
              (org-agenda-skip-function '(org-agenda-skip-entry-if 'notdeadline))
              (org-agenda-format-date (lambda (date) ""))))
  (agenda* "" ((org-agenda-block-separator ? )
               (org-agenda-skip-function '(fpi/org-agenda-skip-if-not-today))
               (org-deadline-warning-days 0)
               (org-agenda-todo-ignore-timestamp 'all)
               (org-agenda-start-day "+0d")
               (org-agenda-span 'day)
               (org-agenda-overriding-header "âš¡ Schedule:\nâŽºâŽºâŽºâŽºâŽºâŽºâŽºâŽºâŽº")
               (org-agenda-repeating-timestamp-show-all nil)
               (org-agenda-remove-tags t)
               (org-agenda-use-time-grid t)
               ;; (org-agenda-prefix-format   "  %-3i  %30b %t%s")
               (org-agenda-todo-keyword-format " â˜ ")
               (org-agenda-current-time-string "â®œâ”ˆâ”ˆâ”ˆâ”ˆâ”ˆâ”ˆâ”ˆ now")
               (org-agenda-scheduled-leaders '("" ""))
               (org-agenda-time-grid (quote ((daily today remove-match)
                                             (0900 1200 1500 1800 2100)
                                             "      " "â”ˆâ”ˆâ”ˆâ”ˆâ”ˆâ”ˆâ”ˆâ”ˆâ”ˆâ”ˆâ”ˆâ”ˆâ”ˆ")))))
  (org-time-budgets-in-agenda-maybe)
  (agenda "" ((org-agenda-block-separator ? )
              (org-agenda-overriding-header "\nâš¡ Scheduled Tasks:\nâŽºâŽºâŽºâŽºâŽºâŽºâŽºâŽºâŽº")
              (org-agenda-skip-function '(org-agenda-skip-entry-if 'notscheduled))
              (org-agenda-use-time-grid nil)
              (org-agenda-format-date (lambda (date) ""))))
  ))
#+end_src
#+begin_src emacs-lisp
(defun fpi/org-agenda-skip-if-not-today ()
  "Skip all scheduled entries and deadlines not due for today."
  (let ((subtree-end (save-excursion (org-end-of-subtree t)))
        (deadline-day
         (when (org-entry-get nil "DEADLINE")
         (time-to-days
          (org-time-string-to-time
           (org-entry-get nil "DEADLINE")))))
        (scheduled-day
         (when (org-entry-get nil "SCHEDULED")
         (time-to-days
          (org-time-string-to-time
           (org-entry-get nil "SCHEDULED")))))
        (now (time-to-days (current-time))))
    (and (or (and deadline-day
                  (not (= deadline-day now)))
             (and scheduled-day
                  (not (= scheduled-day now))))
         subtree-end)))
#+end_src
****** Week agendas
#+begin_src emacs-lisp :tangle no :noweb-ref org-agenda-custom-commands
("w" . "Week agendas")
("ww" "Standard week agenda"
 ((agenda "" ((org-agenda-span 'week)))))
("wt" "This Week's agenda (starting on last Monday)"
 ((agenda "" ((org-agenda-span 'week)
              (org-agenda-start-day "-mon")))
  (tags-todo "+work")))
("wn" "Next Week's agenda"
 ((agenda "" ((org-agenda-span 'week)
              (org-agenda-start-day "mon")))
  (tags-todo "+work")))
#+end_src
****** Misc agendas
#+begin_src emacs-lisp :tangle no :noweb-ref org-agenda-custom-commands
("r" "Refile entries" ((tags "+REFILE")))
("i" "Idle Actions"
       ((tags-todo "IDLE-read-watch"
                   ((org-agenda-overriding-header "Idle Tasks")
                    (org-agenda-skip-function 'bh/skip-project-tasks)
                    (org-agenda-sorting-strategy
                     '(todo-state-down effort-up))))
        (tags-todo "read"
                   ((org-agenda-overriding-header "Idle Reading List")
                    (org-agenda-sorting-strategy
                     '(todo-state-down effort-up))))
        (tags-todo "watch"
                   ((org-agenda-overriding-header "Things to Watch")
                    (org-agenda-skip-function 'bh/skip-project-tasks)
                    (org-agenda-sorting-strategy
                     '(todo-state-down effort-up))))))
("z" "Todos in org-roam-dir"
 ((alltodo ""
           ((org-agenda-files (fpi/collect-org-directories-recursively org-roam-directory))))))
("c" "Agenda and all todos in current directory"
 ((agenda ""
          ((org-agenda-files (fpi/collect-org-directories-recursively default-directory))))
  (alltodo ""
           ((org-agenda-files (fpi/collect-org-directories-recursively default-directory))))))
#+end_src
***** Filtering
****** Auto Exclude
#+begin_src emacs-lisp
;; https://github.com/jwiegley/dot-emacs/blob/master/dot-org.el
(defun org-my-auto-exclude-function (tag)
  (and (cond
        ((string= tag "call")
         (let ((hour (nth 2 (decode-time))))
           (or (< hour 8) (> hour 21))))
        ((string= tag "errand")
         (let ((hour (nth 2 (decode-time))))
           (or (< hour 12) (> hour 17))))
        ((or (string= tag "home") (string= tag "nasim"))
         (with-temp-buffer
           (call-process "ifconfig" nil t nil "en0" "inet")
           (call-process "ifconfig" nil t nil "en1" "inet")
           (call-process "ifconfig" nil t nil "bond0" "inet")
           (goto-char (point-min))
           (not (re-search-forward "inet 192\\.168\\.1\\." nil t))))
        ((string= tag "net")
         (not (quickping "imap.fastmail.com")))
        ((string= tag "fun")
         org-clock-current-task))
       (concat "-" tag)))
#+end_src
****** Stuck projects
The agenda can also list stuck projects with =C-c a #=. For this to be useful we have define what a stuck project is.

A stuck project
1. has any todo state of the states listed in ~org-project-keywords~
2. does /not/ have a subtask with a state of =TODO=, =NEXT= or =INPROGRESS=.

#+begin_src emacs-lisp :tangle no :noweb-ref org-agenda-custom
(org-stuck-projects '("/+{PLANNING\\|READY\\|ACTIVE}" ("TODO" "NEXT" "INPROGRESS") nil ""))
#+end_src
**** Refile
Use the full outline path so I can distinguish headlines with the same name & disable step-wise completion as I think from the refile target backwards, not from top-level downwards. Also include the current file's headings as a refile targets up to a deep level, all agenda files up to a small level and all open org files up to an even smaller level.

As refile only works on file-visiting buffers, we need to filter all other org buffers from ~(org-buffer-list)~.
#+begin_src emacs-lisp
(defun fpi/org-file-buffer-list ()
  "Return a list of org buffers which visit files."
  (seq-filter 'buffer-file-name (org-buffer-list)))
#+end_src

#+begin_src emacs-lisp :noweb-ref org-custom :tangle no
(org-refile-use-outline-path 'file)
(org-refile-targets '((buffer-file-name :maxlevel . 12)
                      (org-agenda-files :maxlevel . 10)
                      (fpi/org-file-buffer-list :maxlevel . 2)))
#+end_src
**** Time budgets
Gives an overview of time spent on defined budgets this week. Great to track if you've worked enough hours. To use it add ~(org-time-budgets-in-agenda-maybe)~ after ~(agenda)~ in a custom agenda command.
#+begin_src emacs-lisp
(use-package org-time-budgets
  :straight (:host github :repo "fpiper/org-time-budgets"
                   :branch "develop"
                   :no-byte-compile t)
  :config
  (setq fpi/dense-time-budgets
        '((:title "Work" :match "+work-nowork" :budget "40:00" :blocks (workday week))
          (:title "Personal" :match "+nowork-nonprod" :budget "5:00" :blocks (nil week))))
  (setq fpi/wide-time-budgets
        '((:title "Work" :match "+work-nowork" :budget "40:00" :blocks (workday week))
                      (:title "â”œResearch" :match "+work+research" :budget "24:00" :blocks (nil week))
                      (:title "â”œTeaching" :match "+work+teaching" :budget "8:00" :blocks (nil week))
                      (:title "â•°Reading" :match "+work+read" :budget "5:00" :blocks (workday week))
                      (:title "Personal" :match "+nowork-nonprod" :budget "5:00" :blocks (nil week))))
  (setq org-time-budgets fpi/wide-time-budgets)
  (defun fpi/toggle-time-budgets ()
    "Toggle between dense and wide time budgets."
    (interactive)
    (if (eq org-time-budgets fpi/wide-time-budgets)
        (progn
            (setq org-time-budgets fpi/dense-time-budgets)
            (message "Set dense time budgets"))
      (setq org-time-budgets fpi/wide-time-budgets)
      (message "Set wide time budgets"))))
#+end_src
**** Column view
#+begin_src emacs-lisp
(setq org-columns-default-format
      "%50ITEM(Task) %5Effort(Effort){:} %5CLOCKSUM %3PRIORITY %20DEADLINE %20SCHEDULED %20TIMESTAMP %TODO %CATEGORY %TAGS")
#+end_src
**** Clocking
I try to clock without any gap
#+begin_src emacs-lisp :tangle no :noweb-ref org-agenda-custom
(org-agenda-clock-consistency-checks '(:max-duration "10:00" :min-duration 0 :max-gap "0:00" :gap-ok-around ("4:00") :default-face ((:background "DarkRed") (:foreground "white")) :overlap-face nil :gap-face nil :no-end-time-face nil :long-face nil :short-face nil))

#+end_src
***** Combine adjacent clock lines
#+begin_src emacs-lisp
(defun fpi/org-clock-join-last-clock ()
  "Join current clock with last one if start/end point match."
  (save-mark-and-excursion
    (beginning-of-line)
    (let* ((eol (save-excursion (end-of-line) (point)))
	   (boi (progn (re-search-forward "\\[" eol t) (backward-char) (point)))
	   (eoi (progn (re-search-forward "\\]" eol t) (point)))
	   (i (buffer-substring-no-properties boi eoi)) ;; last clock-in-time
	   (boc (progn (re-search-forward "\\[" eol t) (backward-char) (point)))
	   (eoc (progn (re-search-forward "\\]" eol t) (point)))
	   (c (buffer-substring-no-properties boc eoc))) ;; last clock-out-time (equals org-clock-out-time if last clock)
      (next-line)
      (end-of-line)
      (let* ((bol (save-excursion (beginning-of-line) (point)))
	     (eoo (progn (re-search-backward "\\]" bol t) (forward-char) (point)))
	     (boo (progn (re-search-backward "\\[" bol t) (point)))
	     (o (buffer-substring-no-properties boo eoo))) ;; last-last clock-out-time
	(when (equal i o)
	  (delete-region boo eoo)
	  ;; (insert (format-time-string (org-time-stamp-format t t) org-clock-out-time))
	  (insert c)
	  (org-evaluate-time-range)
	  (previous-line)
	  (delete-region (save-excursion (beginning-of-line) (backward-char) (point)) eol)
	  (message (format "Joined nearby clocks at %s" i)))))))
(add-hook 'org-clock-out-hook 'fpi/org-clock-join-last-clock)
#+end_src
***** org-clock-convenience
#+begin_src emacs-lisp
(use-package org-clock-convenience
  :straight t
  :bind (:map org-agenda-mode-map
   	   ("<S-up>" . org-clock-convenience-timestamp-up)
   	   ("<S-down>" . org-clock-convenience-timestamp-down)
   	   ("<C-right>" . org-clock-convenience-fill-gap)
   	   ("<C-left>" . org-clock-convenience-fill-gap-both)))
#+end_src
*** org-checklist
#+begin_quote
This file provides some functions for handing repeated tasks which involve
checking off a list of items. By setting the RESET_CHECK_BOXES property in an
item, when the TODO state is set to done all checkboxes under that item are
cleared. If the LIST_EXPORT_BASENAME property is set, a file will be created
using the value of that property plus a timestamp, containing all the items
in the list which are not checked. Additionally the user will be prompted to
print the list.
#+end_quote
#+begin_src emacs-lisp
(use-package org-checklist
  :after org
  :straight (org-contrib))
#+end_src
*** Handling web urls
**** org-web-tools
:PROPERTIES:
:ID:       dc4129ff-6d76-4f12-926f-c62a687a39ec
:END:
This provides functions to get webpage title or content for org mode links.
#+begin_src emacs-lisp
(use-package org-web-tools
  :straight t)
#+end_src
#+begin_src emacs-lisp :noweb-ref fpi-bindings :tangle no
(fpi/define-key fpi-map "l" #'org-web-tools-insert-link-for-url "Link (org)")
#+end_src

*** Gnorb
:PROPERTIES:
:ID:       990e2668-11d6-45eb-9c9b-1dc0b89b556d
:END:
This combines [[file:gnus.org][Gnus]] conversations with Org mode for note taking and [[id:390b66e5-b123-4cb1-9a56-61e41d7a818a][BBDB]] for contact information.
#+begin_src emacs-lisp
(use-package gnorb
  :straight t
  :config
  (gnorb-install-defaults)
  :custom
  <<gnorb-custom>>)
#+end_src
To setup =gnorb= we need to do several things according to [[info:gnorb#Tracking Setup][the manual]]:
1. Activate the gnus registry with ~(gnus-registry-initialize)~
2. Make sure global id tracking in org-id is enabled
   #+begin_src emacs-lisp :noweb-ref org-id-custom :tangle no
   (org-id-track-globally t)
   #+end_src
3. Add nngnorb to ~gnus-secondary-select-methods~
4. Call ~(gnorb-tracking-initialize)~. As this requires =gnus= to be loaded, this is called in =gnus.org=
5. Set gnorb saved messages groups
  #+begin_src emacs-lisp :tangle no :noweb-ref gnorb-custom
  (gnorb-gnus-sent-groups '("nnimap+imsmail:INBOX/work" "nnimap+imsmail:Gesendete ELemente"))
  #+end_src
6. Set todo capture template
   #+begin_src emacs-lisp :tangle no :noweb-ref gnorb-custom
   (gnorb-gnus-new-todo-capture-key "t")
   #+end_src

Default keybindings:
#+begin_example emacs-lisp
(global-set-key (kbd "C-c A") 'gnorb-restore-layout)
(eval-after-load "gnorb-bbdb"
  '(progn
     (define-key bbdb-mode-map (kbd "C-c S") #'gnorb-bbdb-mail-search)
     (define-key bbdb-mode-map (kbd "C-c l") #'gnorb-bbdb-open-link)
     (define-key bbdb-mode-map [remap bbdb-mail] #'gnorb-bbdb-mail)
     (eval-after-load "gnorb-org"
       (org-defkey org-mode-map (kbd "C-c C") #'gnorb-org-contact-link))))
(eval-after-load "gnorb-org"
  '(progn
     (org-defkey org-mode-map (kbd "C-c t") #'gnorb-org-handle-mail)
     (org-defkey org-mode-map (kbd "C-c v") #'gnorb-org-view)
     (org-defkey org-mode-map (kbd "C-c E") #'gnorb-org-email-subtree)
     (setq gnorb-org-agenda-popup-bbdb t)
     (eval-after-load "org-agenda"
       '(progn (org-defkey org-agenda-mode-map (kbd "C-c t") #'gnorb-org-handle-mail)
               (org-defkey org-agenda-mode-map (kbd "C-c v") #'gnorb-org-view)))))
(eval-after-load "gnorb-gnus"
  '(progn
     (define-key gnus-summary-mime-map "a" #'gnorb-gnus-article-org-attach)
     (define-key gnus-summary-mode-map (kbd "C-c t") #'gnorb-gnus-incoming-do-todo)
     (define-key gnus-summary-mode-map (kbd "C-c v") #'gnorb-gnus-view)
     (define-key gnus-summary-mode-map (kbd "C-c C-t") #'gnorb-gnus-tag-message)
     (define-key gnus-summary-limit-map (kbd "g") #'gnorb-gnus-insert-tagged-messages)
     (define-key gnus-summary-limit-map (kbd "G") #'gnorb-gnus-insert-tracked-messages)
     (setq gnorb-gnus-capture-always-attach t)
     (push '("attach to org heading" . gnorb-gnus-mime-org-attach)
           gnus-mime-action-alist)
     (push '(gnorb-gnus-mime-org-attach "a" "Attach to Org heading")
           gnus-mime-button-commands)
     (setq gnus-mime-button-map
           (let ((map (make-sparse-keymap)))
             (dolist (c gnus-mime-button-commands)
               (define-key map (cadr c) (car c)))
             map))))
(eval-after-load "message"
  '(progn
     (define-key message-mode-map (kbd "C-c t") #'gnorb-gnus-outgoing-do-todo)))
#+end_example
**** More refile targets
Make gnorb consider the same refile targets as org.
#+begin_src emacs-lisp :tangle no :noweb-ref gnorb-custom
(gnorb-gnus-trigger-refile-targets org-refile-targets)
#+end_src
*** Inline images

Resize inline images to 400px but respect width specifications in attribute lines.
#+begin_src emacs-lisp :noweb-ref org-custom :tangle no
(org-image-actual-width '(600))
#+end_src
Also display remote images by downloading them.
#+begin_src emacs-lisp :noweb-ref org-custom :tangle no
(org-display-remote-inline-images 'download)
#+end_src

#+begin_src emacs-lisp :noweb-ref ob-hooks :tangle no
(org-babel-after-execute . org-redisplay-inline-images)
#+end_src
*** Babel
This function is handy to use in header arguments to create names based on the current org heading. E.g. =:var data=(fpi/format-headline "/tmp/prefix_")=
#+begin_src emacs-lisp
(defun fpi/format-headline (&optional pre post)
  (let ((pre (or pre ""))
        (post (or post "")))
    (format "%s%s%s" pre (nth 4 (org-heading-components)) post)))
#+end_src

We can also create unique names based on the source block content and header information.
#+begin_src emacs-lisp
(defun fpi/org-babel-get-src-block-hash (&optional block)
  "Return a hash based on src block content and header.

This function tries to not take any file positions into account
and always return the same hash given the same source code and
same header arguments.

`org-babel-sha1-hash' may provide the same feature, but I
discovered that function only after writing this."
  (save-mark-and-excursion
    (if block (org-babel-goto-named-src-block block))
    (let* ((info (org-babel-get-src-block-info t))
           (body (nth 1 info))
           (header (nth 2 info))
           (hashstring (format "%s%s" body header)))
      (md5 hashstring))))

(setq fpi/org-babel-outfile-directory "/tmp/babel")
(make-directory fpi/org-babel-outfile-directory t)

(defun fpi/org-babel-src-block-temp-file (&optional suffix prefix directory block)
  "Return a unique filename based on src block content and header.

This function is intended as an alternative to
`org-babel-temp-file' to provide unique and constant output
filenames. Optionally provide SUFFIX or PREFIX of the filename
and the file DIRECTORY. If SUFFIX or PREFIX is a list its content
will be concatenated. Default directory is
`org-babel-temporary-directory'. Optionally provide a source
block name BLOCK.
 "
  ;; FIXME Way to create really unique names. In case same code can produce different outputs (e.g. based on time, file context)
  (let ((hash (fpi/org-babel-get-src-block-hash block))
        (directory (or
                    directory
                    fpi/org-babel-outfile-directory))
        (suffix (if (listp suffix)
                    (mapconcat (lambda (x)
                                 (cond ;; FIXME possible to handle all cases without cond?
                                  ((symbolp x) (symbol-name x))
                                  ((numberp x) (number-to-string x))
                                  (t x)
                                  )) suffix "")
                  suffix))
        (prefix (if (listp prefix)
                    (mapconcat (lambda (x)
                                 (cond ;; FIXME possible to handle all cases without cond?
                                  ((symbolp x) (symbol-name x))
                                  ((numberp x) (number-to-string x))
                                  (t x)
                                  )) prefix "")
                  prefix))
        (prefix (or prefix ""))
        )
    (expand-file-name (format "%s%s%s" prefix hash suffix) directory)
    ))
(defalias 'fpi/ob-name #'fpi/org-babel-src-block-temp-file)
#+end_src

Now wen can set something like ~:file (fpi/ob-name ".png")~ on all source blocks where we do not care about the output file name.

Some tests for ~fpi/ob-name~:
#+begin_src emacs-lisp :results value replace :tangle no :exports both
(list
 (fpi/ob-name)
 (fpi/ob-name "-SUFFIX")
 (fpi/ob-name nil "PREFIX-")
 (fpi/ob-name "-SUFFIX" "PREFIX-")
 (fpi/ob-name '("-SUF" 42 FIX))
 )
#+end_src

#+RESULTS:
| /tmp/babel-gwZcjh/291f3f60f3e5d467584a3b5bda4d7b05 | /tmp/babel-gwZcjh/291f3f60f3e5d467584a3b5bda4d7b05-SUFFIX | /tmp/babel-gwZcjh/PREFIX-291f3f60f3e5d467584a3b5bda4d7b05 | /tmp/babel-gwZcjh/PREFIX-291f3f60f3e5d467584a3b5bda4d7b05-SUFFIX | /tmp/babel-gwZcjh/291f3f60f3e5d467584a3b5bda4d7b05-SUF42FIX |

*** ol-bbdb
#+begin_src emacs-lisp
(use-package ol-bbdb)
#+end_src
*** icalendar support
While =org-caldav= offers syncing with caldav servers it relies on =ox-icalendar= to convert between org entries and icalendar events.
**** org-caldav
#+begin_src emacs-lisp
(use-package org-caldav
  :straight t
  :custom
  (org-caldav-url private/calendar-url)
  (org-caldav-calendar-id private/calendar-id)
  (org-caldav-inbox "~/sync/w.org")
  (org-caldav-files nil)
  (org-caldav-sync-direction 'cal->org)
  (org-caldav-delete-calendar-entries 'never)
  (org-caldav-exclude-tags nil)
)
#+end_src
**** ox-icalendar
#+begin_src emacs-lisp
(use-package ox-icalendar
  :after org
  :custom
  (org-icalendar-store-UID t))
#+end_src
*** prettify symbols
Set some prettify symbols for org mode.
#+begin_src emacs-lisp
(defun fpi/add-org-prettify-symbols ()
  "Beautify Org Checkbox Symbol"
  (setq prettify-symbols-alist
        (append prettify-symbols-alist
                '(("#+BEGIN_SRC" . ?Â»)
                  ("#+END_SRC" . ?Â«)
                  ("#+begin_src" . ?Â»)
                  ("#+end_src" . ?Â«)
                  ("[ ]" .  ?â˜)
                  ("[X]" . ?â˜‘ )
                  ("[-]" . ?â )))))
(add-hook 'org-mode-hook 'fpi/add-org-prettify-symbols)
#+end_src
*** org-roam
Org-roam mainly provides a display of backlinks to the current file. This allows the creation of a one-subject-per-file Zettelkasten.
#+begin_src emacs-lisp :tangle tangle/emacs-10-init.el :noweb yes :results silent
(use-package org-roam
  :straight (:host github
                   :repo "org-roam/org-roam"
                   :files (:defaults "extensions/*")
                   :no-byte-compile t)
  :after magit
  :custom
  (org-roam-directory "~/git/projects/zettel")
  (org-roam-v2-ack t)
  (org-roam-mode-section-functions
   '(org-roam-backlinks-section
     org-roam-reflinks-section
     org-roam-unlinked-references-section))
  (org-roam-capture-templates
   (quote
    <<org-roam-capture-templates()>>
    ))
  :config
  (org-roam-db-autosync-mode 1)
  (add-to-list 'display-buffer-alist
               '("\\*org-roam\\*"
                 (display-buffer-in-direction)
                 (direction . below)
                 (window-height . 0.3)))
  :bind
  (:map org-roam-mode-map
        (
         <<org-roam-bindings>>
         )
        :map org-mode-map
        (
         <<org-roam-bindings>>
         )))
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref org-roam-bindings
("C-c n f" . org-roam-node-find)
("C-c n i" . org-roam-node-insert)
("C-c n t" . org-roam-buffer-toggle)
("C-c n c" . org-roam-capture)
#+end_src
#+begin_src emacs-lisp :noweb-ref fpi-bindings :tangle no
(fpi/define-key fpi-map "r" #'org-roam-node-find "Roam")
#+end_src

#+begin_src emacs-lisp
(use-package org-roam-ui
  :straight (:host github :repo "org-roam/org-roam-ui" :branch "main" :files ("*.el" "out"))
  :after org-roam
  :custom
  (org-roam-ui-browser-function #'browse-url-generic))
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref org-roam-bindings
("C-c n u" . org-roam-ui-mode)
#+end_src

The idea of ~fpi/org-roam-todo~ is from a post by [[https://oremacs.com/2020/12/31/happy-new-year/][aboabo]]. It lists all open todos in zettelkasten entries and is a (faster) alternative to running an todo agenda with ~org-agenda-files~ set to ~org-roam-directory~.
#+begin_src emacs-lisp :tangle no :noweb-ref org-roam-config
(defun fpi/org-roam-todo ()
  (interactive)
  (setq unread-command-events
          (listify-key-sequence (kbd "C-c C-o M->")))
  (counsel-rg "^\\*+ \\(NEXT\\|TODO\\)" org-roam-directory "--sort modified"))
#+end_src

As =C-c n t= is already taken, use =o= (mnemonic: â€œopenâ€) instead.
#+begin_src emacs-lisp :tangle no :noweb-ref org-roam-bindings
("C-c n o" . fpi/org-roam-todo)
#+end_src

**** org-roam capture templates
Here we define some capture templates for roam files. Using variables in the source block header we can define the template contents in quote blocks below.

#+HEADER: :var default=org-roam-template-default ref=org-roam-template-ref
#+HEADER: :var entities=org-roam-template-entities work=org-roam-template-work
#+HEADER: :var personal=org-roam-template-personal private=org-roam-template-private
#+NAME: org-roam-capture-templates
#+begin_src emacs-lisp :tangle no :noweb yes :results code silent
`(
  ("d" "Default (avoid this)" plain "%?"
   :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" ,default)
   :unnarrowed t)
  ("l" "Link/Reference" plain "%?"
   :if-new (file+head "Ref/${slug}.org" ,ref)
   :unnarrowed t)
  ("e" "Entity (Person, Company, â€¦)" plain "%?"
   :if-new (file+head "Entities/${slug}.org" ,entities)
   :unnarrowed t)
  ("w" "Work related zettel" plain "%?"
   :if-new (file+head "Work/%<%Y%m%d%H%M%S>-${slug}.org" ,work)
   :unnarrowed t)
  ("p" "Personal/Non-work related zettel" plain "%?"
   :if-new (file+head "Personal/%<%Y%m%d%H%M%S>-${slug}.org" ,personal)
   :unnarrowed t)
    ("P" "Private zettel" plain "%?"
   :if-new (file+head "Personal/Private/%<%Y%m%d%H%M%S>-${slug}.org" ,private)
   :unnarrowed t)
  )
#+end_src

As capture templates get more complex storing the template itself in a separate file â€“ or org-babel source block â€“ can be helpful. Above are my (all very similar) template definitions; below the template contents.

#+NAME: org-roam-template-default
#+begin_quote
#+title: ${title}
#+end_quote
#+NAME: org-roam-template-ref
#+begin_quote
:PROPERTIES:
:ROAM_REFS: ${ref}
:END:
#+title: ${title}
#+end_quote
#+NAME: org-roam-template-entities
#+begin_quote
#+FILETAGS: entity
#+title: ${title}
#+end_quote
#+NAME: org-roam-template-work
#+begin_quote
#+FILETAGS: work
#+title: ${title}
#+end_quote
#+NAME: org-roam-template-personal
#+begin_quote
#+FILETAGS: personal
#+title: ${title}
#+end_quote
#+NAME: org-roam-template-private
#+begin_quote
#+FILETAGS: personal private
#+title: ${title}
#+end_quote
**** org-roam-protocol
#+begin_src emacs-lisp
(use-package org-roam-protocol
  :after org-roam
  :custom (org-roam-capture-ref-templates
           '(("zr" "roam ref" plain "%?"
              :if-new (file+head "Ref/${slug}.org"
                                 "#+title: ${title}")
              :unnarrowed t)
             ("zf" "roam fleeting ref" plain "%?"
              :if-new (file+head "Fleeting/${slug}.org"
                                 "#+title: ${title}")
              :unnarrowed t))))
#+end_src
**** org-roam-bibtex
#+begin_src emacs-lisp
(use-package org-roam-bibtex
  :straight t
  :delight
  :hook (org-roam-mode . org-roam-bibtex-mode)
  :bind (:map org-mode-map
              (("C-c n a" . orb-note-actions)))
  :after bibtex
  :custom
  <<orb-custom>>
  :config
  (defun bibtex-autokey-get-year ()
    "Return year field contents as a string obeying `bibtex-autokey-year-length'."
    (let* ((yearfield (bibtex-autokey-get-field "year"))
           (yearfield (when (equal yearfield "")
                        (substring (bibtex-autokey-get-field "date") 0 4))))
      (substring yearfield (max 0 (- (length yearfield)
                                     bibtex-autokey-year-length)))))
  <<orb-config>>)
#+end_src
Rewrite of ~bibtex-autokey-get-year~ is a crude way to get bibtex to recognize =date= fields as year.

Upon showing the notes of an entry with org-ref an appropriate org-roam note file is automatically created using ~orb-edit-notes~. Here I customize the template for my use.
#+begin_src emacs-lisp :tangle no :noweb-ref orb-custom
(orb-templates
 '(("r" "ref" plain #'org-roam-capture--get-point
    "\n%?\n\n#+BEGIN_SRC bibtex\n%(fpi/orb-capture--get-bibtex-entry)\n#+END_SRC"
    :file-name "${citekey}" :head "#+TITLE: %(fpi/orb-capture--get-first-citekey): ${title}\n#+ROAM_KEY: ${ref}
" :unnarrowed t))
)
#+END_SRC
Here are the functions used.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref orb-config
(defun fpi/orb-capture--get-bibtex-entry ()
  "Return bibtex entry for the roam citekey in current buffer"
  (save-excursion
    (goto-char (point-min))
    (when (re-search-forward "^#\\+ROAM_KEY: cite:\\(.*?\\)[\s\n]")
      (let ((key (match-string 1)))
        (org-ref-get-bibtex-entry key)))))
(defun fpi/orb-capture--get-first-citekey ()
  "Return first part of the roam citekey in current buffer"
  (save-excursion
    (goto-char (point-min))
    (when (re-search-forward "^#\\+ROAM_KEY: cite:\\(.*?\\)[\s\n]")
      (let ((key (match-string 1)))
        (when (string-match "^\\(.*?\\)_" key) (match-string 1 key))))))
#+end_src
*** Org-edna
:PROPERTIES:
:ID:       fd3936c7-9fc5-42d0-990d-32024e23b22f
:END:
=Org-edna= is a great tool to manage =TODO= dependencies. I mainly use it to mark tasks as =NEXT= after switching another task to =DONE=. The functions below are taken from Josh's Emacs Config over at [[https://github.com/mm--/dot-emacs/blob/master/jmm-org-config.org][Github]]. He wrote a =edna-finder= which allows link descriptions and a nice hydra to manage the various =org-edna= properties. I call it in my [[id:22750e48-aaee-4f60-bdce-1d511ebe3375][context aware hydra]] when on an org headline. For more functions and explanations checkout his config.
#+begin_src emacs-lisp
(use-package org-edna
  :straight t
  :after org
  :delight
  :config
  (org-edna-load)
  (defun org-edna-finder/link-ids (&rest ids)
    "Find a list of headlines with given IDs.

Unlike `org-edna-finder/ids', IDS here can be links of the form \"[[id:UUID][Headline]]\" (in quotes).
This allows for easier readability of targets."
    (mapcar (lambda (id) (save-window-excursion
                           (org-open-link-from-string id)
                           (point-marker)))
            ids))
  (defun jmm/org-edna-set-trigger-and-point (triggervalue)
    "Set the TRIGGER property to TRIGGERVALUE. Move the point to
the newly set value. Open the PROPERTIES drawer."
    (let ((property "TRIGGER"))
      (org-entry-put (point) property triggervalue)
      (org-back-to-heading t)
      (let* ((beg (point))
             (range (org-get-property-block beg 'force))
             (end (cdr range))
             (case-fold-search t))
        (goto-char (1- (car range)))	;Need to go one character back to get property-drawer element
        (let ((element (org-element-at-point)))
          (when (eq (org-element-type element) 'property-drawer)
            (org-flag-drawer nil element)))
        (goto-char (car range))
        (re-search-forward (org-re-property property nil t) end t))))
  (defun jmm/org-edna-chain-next ()
    "Set TRIGGER to chain next"
    (interactive)
    (jmm/org-edna-set-trigger-and-point "next-sibling todo!(NEXT) chain!(\"TRIGGER\")"))
  (defun jmm/org-pop-stored-link ()
    "Get the string for the previously stored link, then remove it from `org-stored-links'"
    (let* ((firstlink (car org-stored-links))
           (link (car firstlink))
           (desc (cadr firstlink)))
      (setq org-stored-links (delq (assoc link org-stored-links)
                                   org-stored-links))
      (org-make-link-string link desc)))
  (defun jmm/org-edna-link (&optional rest)
    "Set TRIGGER to chain next. With option"
    (interactive)
    (jmm/org-edna-set-trigger-and-point
     (format "link-ids(\"%s\")%s" (jmm/org-pop-stored-link) (if rest (concat " " rest) ""))))
  (defhydra fpi/org-edna-hydra (:color blue :hint nil)
    "
Org Edna
  _l_: Link               _P_: N+p
  _L_: Link NEXT          _p_: Parent DONE
  _n_: Sibling NEXT       ^ ^
  _N_: Chain sibling NEXT _q_: quit
"
    ("l" jmm/org-edna-link)
    ("L" (jmm/org-edna-link "todo!(NEXT)"))
    ("n" (jmm/org-edna-set-trigger-and-point "next-sibling todo!(NEXT)"))
    ("N" (jmm/org-edna-set-trigger-and-point "next-sibling todo!(NEXT) chain!(\"TRIGGER\")"))
    ("P" (jmm/org-edna-set-trigger-and-point "if next-sibling todo-state?(HOLD) then else next-sibling todo!(NEXT) endif next-sibling chain!(\"TRIGGER\") if siblings then parent todo!(DONE) endif"))
    ("p" (jmm/org-edna-set-trigger-and-point "parent todo!(DONE)"))
    ("q" nil)))
#+end_src
*** org-attach
=org-attach= is useful to attach reference material to org files. This can be reference images, data or other files. A special link type is available for attached files: ~[[attachment:file]]~.

- Inheritance :: While inheritance for attachments sounds useful, so subheadings can access their parents attachments, I find that the current implementation (Org 9.3.1) instead of inheriting just sets the attachment dir of all children to that of the parent. So for now I decided not to use it.
- Attachment Folder :: While I do not like the default double nested
  folder structure it creates, I also do not want to set an individual
  =DIR= property for all headings I want to attach something to.
  Instead I define a new function to use the uuid directly as the
  folder name.
#+begin_src emacs-lisp
(use-package org-attach
  :custom
  (org-attach-use-inheritance nil)
  (org-attach-preferred-new-method 'id)
  (org-attach-store-link-p t)
  :config
  (defun fpi/org-attach-id-folder-format (id)
    id)
  (defun fpi/org-attach-id-ts-folder-format (id)
    "Timestamp id converter to ids generated in the \"%FT%T%z\" format."
    (format "%s/%s"
	    (substring id 0 7)
	    (substring id 8)))
  (add-to-list 'org-attach-id-to-path-function-list 'fpi/org-attach-id-folder-format)
  (add-to-list 'org-attach-id-to-path-function-list 'fpi/org-attach-id-ts-folder-format))
#+end_src
=org-attach-git= auto-commits changes to attachments if the directory
is a git repository. I want every attachments to be saved using
=git-annex=. I stopped using this because the buildin =git annex
assistant= seems like a better choice, as it also handles automatic
content syncing upon commit.
#+begin_src emacs-lisp :tangle no
(use-package org-attach-git
  :custom
  (org-attach-git-annex-cutoff 0))
#+end_src
Also exclude =ATTACH= from the inherited tags
#+begin_src emacs-lisp :tangle no :noweb-ref org-custom-no-inheritance-tags
"ATTACH"
#+end_src
*** Org-Capture
#+BEGIN_SRC emacs-lisp
(setq org-journal-file (format "~/sync/journal/%s.org" (nth 2 (calendar-current-date))))
(use-package org-capture
  :after org
  :custom
  (
   (org-capture-templates
    `(
<<org-capture-templates>>))
   (org-capture-templates-contexts
    '(
      <<org-capture-templates-contexts>>))))
#+END_SRC

**** Templates
:PROPERTIES:
:header-args:emacs-lisp: :eval never :noweb yes
:END:
***** Journal
Capture templates for journal entries. Mostly to just keep track of things I have looked at and which may be interesting later, but do not warrant a zettel right now.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-capture-templates
("j" "Journal")
("jj" "Link Current buffer"
 entry
 (file+olp+datetree
  ,org-journal-file)
 ;; "** %<%H:%M> %a\n %i%? \n%:description\n%:elfeed-entry-content\n%:elfeed-entry-date\n%:elfeed-entry-meta\n%:elfeed-entry-title\n%:elfeed-entry-enclosures\n%:elfeed-entry-tags" )
 "** %a
:PROPERTIES:
:CREATED: %U
:END:
%i%?" )
("je" "Manual Entry"
 entry
 (file+olp+datetree
  ,org-journal-file)
 "** %?
:PROPERTIES:
:CREATED: %U
:END:
%i" )
#+END_SRC
To get the title from the url in =kill-ring= I use [[id:dc4129ff-6d76-4f12-926f-c62a687a39ec][org-web-tools]].
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-capture-templates
("jw" "Web Link from kill-ring"
 entry
 (file+olp+datetree
  ,org-journal-file)
 "** %(org-web-tools--org-link-for-url (org-web-tools--get-first-url))%?
:PROPERTIES:
:CREATED: %U
:END:
%i")
#+END_SRC
***** Clock
#+begin_src emacs-lisp :tangle no :noweb-ref org-capture-templates
("c" "Clock"
 plain
 (file "~/sync/refile.org")
 "%(fpi/org-clock-in-heading)")
#+end_src
***** Interrupts
For interruptions. These are saved in a global refile file and to be sorted to their appropriate place.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-capture-templates
("i" "Interrupt"
 entry
 (file "~/sync/refile.org")
 "** %?
:PROPERTIES:
:CREATED: %U
:SOURCE: %a
:END:
:LOGBOOK:
:END:
"
 :clock-in t
 :clock-resume t)
#+END_SRC
***** Appointments
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-capture-templates
("a" "Appointment"
 entry
 (id "802014b3-fddf-4090-b140-7fb62cb982f2")
 "** %?
:PROPERTIES:
:CREATED: %U
:DATE: %^t
<<org-capture-template-properties>>
:SOURCE: %a
:END:
"
 )
#+END_SRC
***** Tasks
Instead of project related capture templates, I use the same template for all tasks and refile them manually to where they belong.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-capture-templates
("t" "Task"
 entry
 (file "~/sync/refile.org")
 "** NEXT %?
:PROPERTIES:
:CREATED: %U
<<org-capture-template-properties>>
:SOURCE: %a
:END:
%i")
#+END_SRC
***** Plans & Ideas
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-capture-templates
("P" "Plans/Ideas"
 entry
 (file "~/sync/refile.org")
 "*** PLANNING %?
:PROPERTIES:
:CREATED: %U
<<org-capture-template-properties>>
:SOURCE: %a
:END:
%i")
#+END_SRC
***** Reply to Mail
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-capture-templates
("r" "Respond" entry (file "~/sync/refile.org")
 "* NEXT Respond to %:from on %:subject
:PROPERTIES:
:CREATED: %U
<<org-capture-template-properties>>
:END:
%a" :immediate-finish t)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-capture-templates-contexts
("r" ((in-mode . "gnus-summary-mode")
                     (in-mode . "gnus-article-mode")))
#+END_SRC
***** Interesting stuff I have to look at later
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-capture-templates
("C" "Checkout")
("Cr" ".. & read"
 entry
 (file "~/sync/refile.org")
 "* TODO %a  :read:
:PROPERTIES:
:CREATED: %U
<<org-capture-template-properties>>
:SOURCE: %a
:END:
%?
")
#+END_SRC
***** Ledger transactions
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-capture-templates
("l" "Ledger")
            ("lb" "Bank" plain (file ,(format "~/.personal/f/%s.ledger" (format-time-string "%Y")))
             ,private/org-ledger-card-template
             :empty-lines 1
             :immediate-finish t)
            ("lc" "Cash" plain (file ,(format "~/.personal/f/%s.ledger" (format-time-string "%Y")))
             ,private/org-ledger-cash-template
             :empty-lines 1
             :immediate-finish t)
#+END_SRC
***** org-protocol
:PROPERTIES:
:ID:       28704dfb-7647-43ac-b96f-5967383d1188
:END:
Org-protocol is an easy way to capture stuff from outside emacs.
#+begin_src emacs-lisp :tangle tangle/emacs-10-init.el :eval yes :results silent
(use-package org-protocol)
#+end_src
To install the handler for =org-protocol://= URIs under linux you probably need a =.desktop= file similar to the one below. Place it under =~/.local/share/applications= and run src_shell{update-desktop-database}.
# #+HEADER: :tangle ~/.local/share/applications/org-protocol.desktop
#+begin_src conf
[Desktop Entry]
Version=1.0
Encoding=UTF-8
Name=Org Protocol
Comment=OrgProtocol URI handler
Exec=/home/fpi/.local/bin/emacsclient %u
Type=Application
Terminal=false
MimeType=x-scheme-handler/org-protocol;âŽ
#+end_src
Under Windows install a registry key. The example below works for Emacs running under WSL. Place it in a =.reg= file and open it with the registry editor to install.
# #+HEADER: :tangle ~/win/tmp/org-protocol.reg
#+begin_src conf
REGEDIT4

[HKEY_CLASSES_ROOT\org-protocol]
@="URL:Org Protocol"
"URL Protocol"=""
[HKEY_CLASSES_ROOT\org-protocol\shell]
[HKEY_CLASSES_ROOT\org-protocol\shell\open]
[HKEY_CLASSES_ROOT\org-protocol\shell\open\command]
@="\"C:\\Windows\\System32\\wsl.exe\" emacsclient \"%1\""
#+end_src

To be compatible with [[https://github.com/sprig/org-capture-extension][this chromium/firefox extension]] I use these capture templates:
#+begin_src emacs-lisp :tangle no :noweb-ref org-capture-templates
	("p" "Protocol" entry (file+olp+datetree ,org-journal-file)
        "* %^{Title}
:PROPERTIES:
:SOURCE: %c
:CREATED: %U
:END:
#+BEGIN_QUOTE\n%i\n#+END_QUOTE\n\n\n%?")
("L" "Protocol Link" entry (file+olp+datetree ,org-journal-file)
        "* %? [[%:link][%:description]]
:PROPERTIES:
:CREATED: %U
:ID: %(org-id-new)
:ROAM_REFS: %:link
:END:
")
#+end_src
***** Old templates
Templates I no longer use, but may be interesting.
#+BEGIN_SRC emacs-lisp :tangle no
("n" "note" entry (file "~/sync/refile.org")
 "* %? :NOTE:\n%U\n%a\n" :clock-in t :clock-resume t)
("j" "Journal/Interruptions" entry (file+olp+datetree "~/sync/diary.org")
 "* %?\n%U\n" :clock-in t :clock-resume t)
("h" "Habit" entry (file "~/sync/refile.org")
 "* NEXT %?\n%U\n%a\nSCHEDULED: %(format-time-string \"%<<%Y-%m-%d %a .+1d/3d>>\")\n:PROPERTIES:\n:STYLE: habit\n:REPEAT_TO_STATE: NEXT\n:END:\n")
("m" "Meeting" entry (file "~/sync/refile.org")
 "* MEETING with %? :MEETING:\n%U" :clock-in t :clock-resume t)
("p" "Phone call" entry (file "~/sync/refile.org")
 "* PHONE %? :PHONE:\n%U" :clock-in t :clock-resume t)

("c" "Item to Current Clocked Task" item (clock)
 "%i%?" :empty-lines 1)
("K" "Kill-ring to Current Clocked Task" plain (clock)
 "%c" :immediate-finish t :empty-lines 1)
("p" "Gcal Appointment" entry (file "~/.emacs.d/gcal.org")
 "* %?\n%^T\n")
("z" "Zettel" entry (file "~/zettel.org")
 "* %i%? %(and (org-id-get-create) nil)
:PROPERTIES:\n:CREATED: %u\n:END:\n")
#+END_SRC
**** Setup for floating capture window
For reference see [[https://www.windley.com/archives/2010/12/capture_mode_and_emacs.shtml][here]].
#+begin_src emacs-lisp
(defun fpi/make-floating-frame (&optional width height minibuffer name)
  (interactive)
  (let ((width (or width 80))
        (height (or height 36))
        (name (or name "*Floating Emacs*")))
    (make-frame `((name . ,name)
                  (window-system . x)
                  (width . ,width)
                  (height . ,height)
                  (minibuffer . ,minibuffer)))))

(defadvice org-capture-finalize
    (after delete-capture-frame activate)
  "Advise capture-finalize to close the frame"
  (if (equal "*Capture*" (frame-parameter nil 'name))
      (delete-frame)))
(defadvice org-capture-destroy
    (after delete-capture-frame activate)
  "Advise capture-destroy to close the frame"
  (if (equal "*Capture*" (frame-parameter nil 'name))
      (delete-frame)))
(defun fpi/make-floating-capture-frame ()
  (interactive)
  (select-frame (fpi/make-floating-frame 70 20 t "*Capture*"))
  (add-hook 'org-capture-mode-hook 'delete-other-windows)
  (org-capture)
  (remove-hook 'org-capture-mode-hook 'delete-other-windows))
#+end_src
*** Org Expiry
This is an easy way to (semi-)automatically archive no longer relevant entries.

I want to archive entries sometime after they are set to =DONE=. I first thought about using [[id:fd3936c7-9fc5-42d0-990d-32024e23b22f][Org Edna]]'s =TRIGGER= keyword:
: :TRIGGER: self set-property("EXPIRY" "some-date")
But unfortunately it does not support evaluating lisp for the property value. Therefore either an absolute expiry date has to be known when setting the =TRIGGER= or one needs to use a relative date.

To come by with relatives dates I use the =CLOSED= property as reference for org-expiry when evaluating relative timestamps. The relative timestamp can then already be set directly in the capture template. Ten days gives me enough time to check whether the content is no longer important and to review the clocked times.
#+begin_src fundamental :noweb-ref org-capture-template-properties
:EXPIRY: +10d
#+end_src
As I do not always mark appointments as =DONE=, I set the =CLOSED= property already in the capture template (to the same time as the actual date). This is currently bugged..
#+begin_src fundamental :noweb-ref org-capture-template-closed
CLOSED: %\\1
#+end_src

#+begin_src emacs-lisp
(use-package org-expiry
  :after org
  :straight
  (org-contrib)
  :custom
  (org-expiry-handler-function 'org-expiry-archive-subtree)
  (org-expiry-inactive-timestamps t)
  (org-expiry-created-property-name "CLOSED"))
;; (defun fpi/org-insert-expiry (&optional date)
;;   (interactive)
;;   (let ((date (or date "fri")))
;;     (with-temp-buffer
;;       (org-insert-time-stamp (org-read-date nil t "fri") nil t)
;;       (buffer-string))))
#+end_src
(org-read-date nil nil ".")
*** org-mime
Set ~:preserve-breaks~ to keep line breaks in the html output. =org-mime-export-options= supports the same options as documented in =org-export-options-alist=.
#+begin_src emacs-lisp
(use-package org-mime
  :straight t
  :custom ((org-mime-export-options
            '(:with-latex dvipng
                          :preserve-breaks t))))
#+end_src
*** Ricing
#+begin_src emacs-lisp
(setq line-spacing 0.1)
(setq header-line-format " ")
;; (set-face-attribute 'header-line nil :height 50) ;; make buffer-local first

;; side padding
(lambda ()
  (progn
    (setq left-margin-width 2
          right-margin-width 2)
    (set-window-buffer nil (current-buffer))))

;; try writeroom-mode
#+end_src
*** Org crypt
A small function to toggle the encryption state of the current entry.
#+begin_src emacs-lisp
(use-package org-crypt
  :config
  (defun fpi/org-toggle-crypt-entry ()
    "Encrypt/Decrypt current headline."
    (interactive)
    (require 'epg)
    (when (eq major-mode 'org-mode)
      (unless (org-before-first-heading-p)
        (org-with-wide-buffer
         (org-back-to-heading t)
         (org-end-of-meta-data)
         (if (looking-at-p "-----BEGIN PGP MESSAGE-----")
             (org-decrypt-entry)
           (org-encrypt-entry))))))
  (fpi/define-key fpi/toggle-map "e" #'fpi/org-toggle-crypt-entry "Encrypt"))
#+end_src
*** Reference management
**** Bibtex
#+begin_src emacs-lisp
(use-package bibtex
  :custom
  (bibtex-autokey-titlewords 3)
  (bibtex-autokey-titlewords-stretch 1)
  (bibtex-autokey-titleword-length 5)
  (bibtex-completion-library-path "~/git/projects/personal/Lit")
  :config
  (bibtex-set-dialect 'BibTeX))

(setq bibtex-completion-bibliography "~/git/projects/personal/bib.bib")
(setq bibtex-completion-notes-path "~/git/projects/zettel/Lit")
(setq bibtex-completion-notes-extension ".org")

#+end_src
**** Org Cite
=org-ref= was replaced by =orgcite= which is built into =org=.
#+begin_src emacs-lisp
(use-package oc
  :after org
  :custom
  (org-cite-global-bibliography (if (equal fpi/current-device "DESKTOP-PM1PPEC")
                                    '("~/git/projects/personal/bib.bib"
                                      "~/win/Zotero/00_Unsorted.bib"
                                      "~/win/Zotero/01_Annotated.bib"
                                      "~/win/Zotero/99_AllZotero.bib")
                                  '("~/git/projects/personal/bib.bib"))))
#+end_src
***** Capturing entries
I store my bibtex references in an org file together with my notes. In
addition to saving the meta information in properties using the same
functions as =doi-utils-doi-to-org-bibtex=, I also store them a second
time in a bibtex src block in the heading. The src blocks are tangled
to compile into a separate =.bib= file. The function below creates new
entries from a given doi and is called in my respective capture
template.

Here is my capture template.
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-capture-templates
("b" "Bibtex entry"
 entry
 (id "efc97963-b714-4020-94b6-c23ad2a286ee")
 (function fpi/add-org-from-doi))
#+END_SRC
And the function to create the file.
#+begin_src emacs-lisp
(defun fpi/add-org-from-doi (&optional doi)
  "Get bibtex entry from doi and format as Org header with
properties and additional bibtex src block. Also downloads the
pdf if available."
  (let* ((doi (or doi (read-string "Enter doi: ")))
         (content (replace-regexp-in-string "\n$" "" (doi-utils-doi-to-bibtex-string doi)))
         (cleaned (with-temp-buffer
                    (insert content)
                    (org-ref-clean-bibtex-entry)
                    (org-bibtex-read)
                    (buffer-substring (point-min) (point-max)))))
    (with-temp-buffer
      (org-mode)
      (org-bibtex-write)
      (goto-char (point-max))
      (insert "#+BEGIN_SRC bibtex\n")
      (insert cleaned)
      (insert "\n#+END_SRC\n")
      (org-demote)
      (buffer-substring (point-min) (point-max)))))
#+end_src
Here's a function to easily copy a doi from the results of =crossref-lookup=.
#+begin_src emacs-lisp
(defun fpi/biblio-get-doi ()
  (interactive)
  (let ((doi (alist-get 'doi (cdr (biblio--selection-metadata-at-point)))))
    (kill-new doi)
    (message "Copied doi %s" doi)))
(use-package biblio
  :bind (:map biblio-selection-mode-map
              ("d" . fpi/biblio-get-doi)))
#+end_src
***** org-protocol conversion
Capturing new entries with org-protocol is convenient. To convert the result of  [[id:28704dfb-7647-43ac-b96f-5967383d1188][my capture templates]] to a valid entry, we have to extract the doi.
#+begin_src emacs-lisp
(defun fpi/ieee-to-doi (url)
  "Get doi from an ieeexplore.ieee.org page."
  (let* ((meta (with-current-buffer (url-retrieve-synchronously url)
                (goto-char 1)
                (search-forward "global.document.metadata=")
                (kill-sexp)
                (pop kill-ring)))
         (json (json-read-from-string meta)))
         (alist-get 'doi json)))
#+end_src
Other keys which IEEE returns are:
#+begin_example
(mapcar (lambda (l) (car l)) json)
(userInfo authors isbn articleNumber dbTime metrics purchaseOptions getProgramTermsAccepted sections formulaStrippedArticleTitle allowComments pdfUrl keywords abstract pubLink doiLink rightsLink pdfPath startPage endPage publicationTitle displayPublicationTitle doi issueLink isGetArticle isGetAddressInfoCaptured isMarketingOptIn applyOUPFilter pubTopics publisher isOUP isFreeDocument isSAE isNow isCustomDenial conferenceDate isDynamicHtml isStandard displayDocTitle isNotDynamicOrStatic isPromo htmlAbstractLink xploreDocumentType chronOrPublicationDate isConference isOpenAccess persistentLink isEarlyAccess htmlLink publicationDate isJournal isBook isBookWithoutChapters isChapter isStaticHtml isMorganClaypool isProduct isEphemera accessionNumber dateOfInsertion isACM isSMPTE startPage openAccessFlag ephemeraFlag title confLoc accessionNumber html_flag ml_html_flag sourcePdf content_type mlTime chronDate xplore-pub-id pdfPath isNumber rightsLinkFlag dateOfInsertion contentType publicationDate publicationNumber citationCount xplore-issue articleId publicationTitle sections onlineDate conferenceDate publicationYear subType _value lastupdate mediaPath endPage displayPublicationTitle doi)
#+end_example
Combining this with other functions allows us to do the whole conversion. In the future the citation information can be directly from extracted from the retrieved webpage instead of over the doi.
#+begin_src emacs-lisp
(defun fpi/convert-capture-bib ()
  "Convert current org-protocol ieee capture to bib."
  (interactive)
  (let ((rep (fpi/get-capture-bib-replacement)))
    (kill-region (point-min) (point-max))
    (insert rep)
    ))
(defun fpi/get-capture-bib-replacement ()
  (save-excursion
    (goto-char (point-min))
    (org-next-link)
    (let* ((link (org-element-context))
           (url (concat (org-element-property :type link)
                        ":"
                        (org-element-property :path link))))
      (fpi/add-org-from-doi
       (fpi/ieee-to-doi url)))))

(defun fpi/format-org-roam-from-doi (&optional doi)
  "Get bibtex entry from doi and format for org-roam. Also downloads the
pdf if available."
  (let* ((doi (or doi (read-string "Enter doi: ")))
         (content (replace-regexp-in-string "\n$" "" (doi-utils-doi-to-bibtex-string doi)))
         (cleaned (with-temp-buffer
                    (insert content)
                    (org-ref-clean-bibtex-entry)
                    (org-bibtex-read)
                    (buffer-substring (point-min) (point-max))))
         (parsed (reftex-parse-bibtex-entry cleaned))
         (key (org-ref-reftex-get-bib-field "&key" parsed))
         (first (when (string-match "^\\(.*?\\)_" key) (match-string 1 key)))
         (title (org-ref-reftex-get-bib-field "title" parsed)))
    (setq fpi//capture-bibtex-key key)
    (with-temp-buffer
      (org-mode)
      (insert (format "#+TITLE: %s: %s\n" first title))
      (insert (format "#+ROAM_KEY: cite:%s\n\n" key))
      ;; (org-bibtex-write)
      (goto-char (point-max))
      (insert "#+BEGIN_SRC bibtex\n")
      (insert cleaned)
      (insert "\n#+END_SRC\n")
      (list key
            (buffer-substring (point-min) (point-max))))))

(defun fpi/org-roam-format-from-doi (&optional doi)
  (let* ((doi (or doi (read-string "Enter doi: "))))
    (setq fpi/org-roam-last-captured-doi doi)
    (fpi/format-org-roam-from-doi doi)))

(defvar fpi/org-roam-last-content nil)
(defvar fpi/org-roam-last-key nil)
(defun fpi/org-roam-get-key (doi)
  (let* ((resp (fpi/format-org-roam-from-doi doi))
         (key (car resp))
         (content (cadr resp)))
    (setq fpi/org-roam-last-content content)
    key))
(defun fpi/org-roam-get-last-content ()
  fpi/org-roam-last-content)
(defun fpi/org-roam-get-last-key ()
  fpi/org-roam-last-key)
(defun fpi/org-roam-get-content (doi)
  (let* ((resp (fpi/format-org-roam-from-doi doi))
         (key (car resp))
         (content (cadr resp)))
    (setq fpi/org-roam-last-content content)
    (setq fpi/org-roam-last-key key)
    content))

(defun fpi/create-org-roam-from-doi (&optional doi)
  (interactive)
  (let* ((resp (fpi/format-org-roam-from-doi doi))
         (key (car resp))
         (content (cadr resp)))
    (find-file (expand-file-name (format "Lit/%s.org" key) org-roam-directory))
    (org-mode)
    (insert content)))

(defun fpi/create-org-roam-from-protocol-capture ()
  "Create a org-roam entry from an org-protocol capture buffer."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (org-next-link)
    (let* ((link (org-element-context))
           (url (concat (org-element-property :type link)
                        ":"
                        (org-element-property :path link))))
      (fpi/create-org-roam-from-doi
       (fpi/ieee-to-doi url)))))
#+end_src
*** Toggle drawer visibility
#+begin_src emacs-lisp
(setq fpi/org-meta-heading-info-store nil)
(make-variable-buffer-local 'fpi/org-meta-heading-info-store)
(defun mw-org-hide-meta-heading-info ()
  "Hide meta data following headings."
  (interactive)
  (org-save-outline-visibility t
      (save-excursion
        ;; (widen)
        ;; (org-cycle '(64))
        ;; (org-show-all '(drawers)) ; expand all props before make invisible to avoid ellipses.
        (goto-char (point-min))
        (unless (org-at-heading-p) (outline-next-heading))
        (while (not (eobp))
          (let ((beg (1+ (progn (end-of-line) (point))))
                (end (1- (progn (org-end-of-meta-data t) (point)))))
            (when (< beg end)
              (push (make-overlay beg end) fpi/org-meta-heading-info-store)
              (overlay-put (car fpi/org-meta-heading-info-store) 'invisible t)))
          (when (not (org-at-heading-p))
            (outline-next-heading))))))

(defun mw-org-show-meta-info-lines ()
  "Show meta info."
  (interactive)
  (mapc #'delete-overlay fpi/org-meta-heading-info-store)
  (setq fpi/org-meta-heading-info-store nil))


(defun fpi/org-toggle-meta-info-lines ()
  (interactive)
  (if fpi/org-meta-heading-info-store
      (mw-org-show-meta-info-lines)
    (mw-org-hide-meta-heading-info)))
(fpi/define-key fpi/toggle-map "m" #'fpi/org-toggle-meta-info-lines "Metalines (org)")
#+end_src
*** Table of contents in org
#+begin_src emacs-lisp
(use-package toc-org
  :straight t
  :hook (org-mode .  toc-org-mode))
#+end_src
*** Workflow
My current workflow is largely inspired by [[http://doc.rix.si/cce/cce-org.html][Ryan Rix's]] and [[http://doc.norang.ca/org-mode.html][Bernt
Hansen's]] configs.

First set the ids of some default and often referenced tasks.
#+begin_src emacs-lisp
(setq fpi/organization-task-id "52ac704f-9cc4-4291-9721-aa3cd3b34fae")
(setq fpi/lunch-task "e3d95e3b-416d-4265-835b-1ba57aa84704"
      fpi/break-task "fede843d-02fc-4cdd-8a63-91905e727dab"
      ;; fpi/prep-task "9d6279b8-c921-46e7-8ee4-b4d367dca1e0"
      fpi/morning-flow "2bec1c12-2ee5-4f50-9eac-a018ca081d7d"
      )
#+end_src

This hydra contains most parts of my current workflow. It has
everything from going to certain headlines, clocking time and
capturing notes.
#+begin_src emacs-lisp
(defhydra hydra-workflow (:hint nil)
  "
Searching ----------> Do stuff --------> Do Stuff 2 -------> Workflow ---------------> Nar/Wid ------------------>
_i_: In-file headings   _d_: Clock in        _c_: Capture          _m_: Prep meeting notes     _n_: Narrow to Subtree
_h_: All headings       _e_: Email           _<_: Last Task        _M_: Mail meeting notes     _w_: Widen
_a_: Select an Agenda   _l_: Lunch           _j_: Jump Clock       _B_: BBDB search            _r_: Narrow to region
_g_: Go to active clock _b_: Break           _P_: Insert BBDB      _c_: Capture                _t_: Show TODO Entries
                      _k_: Morning prep    _z_: Capture Note                               _s_: *scratch*
                      _o_: Clock out                                                     _S_: Org Scratch
"
  ("<" bh/clock-in-last-task)
  ("a" org-agenda :exit t)
  ("B" bbdb)
  ("b" rrix/clock-in-break-task) ;; TODO
  ("c" org-capture)
  ("d" bh/punch-in)
  ("e" rrix/clock-in-email-task) ;; TODO
  ("g" org-clock-goto)
  ("h" cce/org-goto-agenda-heading)
  ("i" org-goto)
  ("j" (progn
         (interactive)
         (setq current-prefix-arg '(4))
         (call-interactively 'org-clock-in)))
  ("k" rrix/clock-morning-prep)
  ("l" rrix/clock-in-lunch-task)
  ("M" bh/mail-subtree) ;; TODO ;; checkout org-mime
  ("m" bh/prepare-meeting-notes) ;; TODO
  ("n" bh/narrow-to-subtree) ;; TODO
  ("o" bh/punch-out)
  ("P" bh/phone-call) ;; TODO
  ("r" narrow-to-region) ;; neccessary?
  ("S" bh/make-org-scratch) ;; neccessary?
  ("s" bh/switch-to-scratch) ;; neccessary?
  ("t" bh/org-todo) ;; neccessary?
  ("w" bh/widen) ;; neccessary?
  ("z" cce/note-to-clock))
#+end_src

#+begin_src emacs-lisp :noweb-ref fpi-bindings :tangle no
(fpi/define-key fpi-map (kbd "f") 'hydra-workflow/body "Flow")
#+end_src
Basic flow:
1. Start your work by clocking in with ~bh/punch-in~. This sets a
   predefined "Organizational" entry as default clocking entry and
   clocks you in on it.
2. To start planning your day go to "Morning prep" or directly start
   working on something and clock in on it using either "Jump clock"
   or ~org-clock-in~ normally.
3. Do stuff. Change clocks, capture stuff, take notes, take breaks, â€¦
4. At the end of the day clock out with ~bh/punch-out~.

**** Clocking
While punched in org continues to clock your time. Each time you clock
out of an entry it clocks you in on the parent entry or the default
organizational task.
#+begin_src emacs-lisp
(defun bh/clock-out-maybe ()
  (when (and bh/keep-clock-running
             (not org-clock-clocking-in)
             (marker-buffer org-clock-default-task)
             (not org-clock-resolving-clocks-due-to-idleness))
    (rrix/clock-in-sibling-or-parent-task)))

(add-hook 'org-clock-out-hook 'bh/clock-out-maybe 'append)

(defun rrix/clock-in-sibling-or-parent-task ()
  "Move point to the parent (project) task if any and clock in"
  (let ((parent-task)
        (parent-task-is-flow)
        (sibling-task)
        (curpoint (point)))
    (save-excursion
      (save-restriction
        (widen)
        (outline-back-to-heading)
        (org-cycle)
        (while (and (not parent-task) (org-up-heading-safe))
          (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
            (setq parent-task (point))))
        (goto-char curpoint)
        (while (and (not sibling-task) (org-get-next-sibling))
          (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
            (setq sibling-task (point))))
        (setq parent-task-is-flow (cdr (assoc "FLOW"
                                              (org-entry-properties parent-task))))
        (cond ((and sibling-task
                    parent-task-is-flow)
               (org-with-point-at sibling-task
                 (org-clock-in))
               (org-clock-goto))
              (parent-task
               (org-with-point-at parent-task
                 (org-clock-in))
               (org-clock-goto))
              (t (when bh/keep-clock-running
                   (bh/clock-in-default-task))))))))
(defun bh/clock-in-default-task ()
  (save-excursion
    (org-with-point-at org-clock-default-task
      (org-clock-in)
      (org-clock-goto))))
#+end_src
Define the punch-in and punch-out functions.
#+begin_src emacs-lisp
(defun bh/punch-in (arg)
  (interactive "p")
  (setq bh/keep-clock-running t)
  (if (equal major-mode 'org-agenda-mode)
      (let* ((marker (org-get-at-bol 'org-hd-marker))
             (tags (org-with-point-at marker (org-get-tags-at))))
        (if (and (eq arg 4) tags)
            (org-agenda-clock-in '(16))
          (bh/clock-in-organization-task-as-default)))
    (save-restriction
      (widen)
      (if (and (equal major-mode 'org-mode) (not (org-before-first-heading-p)) (eq arg 4))
          (org-clock-in '(16))
        (bh/clock-in-organization-task-as-default)))))

(defun bh/clock-in-organization-task-as-default ()
  (interactive)
  (org-with-point-at (org-id-find fpi/organization-task-id 'marker)
    (org-clock-in '(16))))

(defun bh/punch-out ()
  (interactive)
  (setq bh/keep-clock-running nil)
  (when (org-clock-is-active)
    (org-clock-out))
  (org-agenda-remove-restriction-lock))
#+end_src
Clocking into a task by id and some default clock-in functions.
The separate functions are needed so they can be used in the hydra.
#+begin_src emacs-lisp
(defun bh/clock-in-task-by-id (id)
  "Clock in a task by id"
  (org-with-point-at (org-id-find id 'marker)
    (org-clock-in nil)))
(setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id)

(defun rrix/clock-in-lunch-task ()
  (interactive)
  (bh/clock-in-task-by-id fpi/lunch-task))
(defun rrix/clock-in-break-task ()
  (interactive)
  (bh/clock-in-task-by-id fpi/break-task)
  (org-agenda nil "i"))

(defun rrix/clock-morning-prep ()
  (interactive)
  (bh/clock-in-task-by-id fpi/morning-flow)
  (org-clock-goto)
  ;; (bh/narrow-to-subtree)
  )
#+end_src
Function to clock into the last task.
#+begin_src emacs-lisp
(defun bh/clock-in-last-task (arg)
  "Clock in the interrupted task if there is one
Skip the default task and get the next one.
A prefix arg forces clock in of the default task."
  (interactive "p")
  (let ((clock-in-to-task
         (cond
          ((eq arg 4) org-clock-default-task)
          ((and (org-clock-is-active)
                (equal org-clock-default-task (cadr org-clock-history)))
           (caddr org-clock-history))
          ((org-clock-is-active) (cadr org-clock-history))
          ((equal org-clock-default-task (car org-clock-history)) (cadr org-clock-history))
          (t (car org-clock-history)))))
    (widen)
    (org-with-point-at clock-in-to-task
      (org-clock-in nil))))
#+end_src
Add a note to the current clock
#+begin_src emacs-lisp
(defun cce/note-to-clock ()
  "Add a note to the currently clocked task."
  (interactive)
  (save-window-excursion
    (org-clock-goto)
    (org-add-note)))
#+END_SRC
**** General
Go to any heading in an agenda file (or more specifically in any file
included in 'org-refile-targets)
#+begin_src emacs-lisp
(defun cce/org-goto-agenda-heading (&optional prompt)
  (interactive)
  (let* ((location (org-refile-get-location (or prompt "Goto")))
         (file (cadr location))
         (marker (car (last location))))
    (find-file file)
    (goto-char marker)
    (org-show-context)
    (current-buffer)))
#+END_SRC
**** Filter functions
Various functions to determine if the current entry is a task, a
project or neither.
#+begin_src emacs-lisp
(defun bh/is-task-p ()
  "Any task with a todo keyword and no subtask"
  (save-restriction
    (widen)
    (let ((has-subtask)
          (subtree-end (save-excursion (org-end-of-subtree t)))
          (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
      (save-excursion
        (forward-line 1)
        (while (and (not has-subtask)
                    (< (point) subtree-end)
                    (re-search-forward "^\*+ " subtree-end t))
          (when (member (org-get-todo-state) org-todo-keywords-1)
            (setq has-subtask t))))
      (and is-a-task (not has-subtask)))))
(defun bh/is-project-p ()
  "Any task with a todo keyword subtask"
  (save-restriction
    (widen)
    (let ((has-subtask)
          (subtree-end (save-excursion (org-end-of-subtree t)))
          (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
      (save-excursion
        (forward-line 1)
        (while (and (not has-subtask)
                    (< (point) subtree-end)
                    (re-search-forward "^\*+ " subtree-end t))
          (when (member (org-get-todo-state) org-todo-keywords-1)
            (setq has-subtask t))))
      (and is-a-task has-subtask))))
(defun bh/find-project-task ()
  "Move point to the parent (project) task if any"
  (save-restriction
    (widen)
    (let ((parent-task (save-excursion (org-back-to-heading 'invisible-ok) (point))))
      (while (org-up-heading-safe)
        (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
          (setq parent-task (point))))
      (goto-char parent-task)
      parent-task)))
(defun bh/is-project-subtree-p ()
  "Any task with a todo keyword that is in a project subtree.
Callers of this function already widen the buffer view."
  (let ((task (save-excursion (org-back-to-heading 'invisible-ok)
                              (point))))
    (save-excursion
      (bh/find-project-task)
      (if (equal (point) task)
          nil
        t))))
(defun bh/skip-project-tasks ()
  "Show non-project tasks.
Skip project and sub-project tasks, habits, and project related tasks."
  (save-restriction
    (widen)
    (let* ((subtree-end (save-excursion (org-end-of-subtree t))))
      (cond
       ((bh/is-project-p)
        subtree-end)
       ((org-is-habit-p)
        subtree-end)
       ((bh/is-project-subtree-p)
        subtree-end)
       (t
        nil)))))
#+end_src
** Deft

#+begin_quote
Deft is an Emacs mode for quickly browsing, filtering, and editing
directories of plain text notes, inspired by Notational Velocity. It
was designed for increased productivity when writing and taking notes
by making it fast and simple to find the right file at the right time
and by automating many of the usual tasks such as creating new files
and saving files.
#+end_quote

I use =Deft= to organize my /Zettelkasten/. It contains many single
files about various topics. =Deft= handles searching and file
creation.
#+begin_src emacs-lisp
(use-package deft
  :straight t
  :custom ((deft-directory "~/git/projects/zettel")
           (deft-extensions '("org"))
           (deft-default-extension "org")
           (deft-use-filename-as-title t)
           (deft-recursive t)
           (deft-use-filter-string-for-filename t)
           <<deft-custom>>))
#+end_src
Most org files start with meta information on lines starting with ~#+~, but also sometimes ~:PROPERTIES:~ drawers. We can exclude these lines from the preview content =Deft= displays with regular expressions. I first noticed this setting in [[https://github.com/hsinhaoyu/.emacs.d/blob/master/config.org][this config by hsin-hao yu]]. Define ~deft-strip-summary-regexp~ to match a group of expressions.
#+begin_src emacs-lisp :tangle no :noweb-ref deft-custom
(deft-strip-summary-regexp
  (rx (group (or
              space
              <<deft-strip-summary-regexps>>
              ))))
#+end_src

Match ~#+~ based meta lines.
#+begin_src emacs-lisp :tangle no :noweb-ref deft-strip-summary-regexps
(seq bol "#+" (+ (any alpha ?_)) ?: (* any) eol)
#+end_src
Match all drawer lines, including the content.
#+begin_src emacs-lisp :tangle no :noweb-ref deft-strip-summary-regexps
(seq bol ?: (*? (not ?:)) ?: (*? (or any "\n")) ":END:")
#+end_src
Match some formatted standard additional information at the start of files.
#+begin_src emacs-lisp :tangle no :noweb-ref deft-strip-summary-regexps
(seq bol "- tags ::" (* any) eol)
(seq bol "- links ::" (* any) eol)
(seq bol "- source ::" (* any) eol)
#+end_src

[[https://github.com/EFLS/zetteldeft][Zetteldeft]] provides further functions to search and link between
different /Zettel/. As /Zettel/ are scattered in separate files,
normal org file links using IDs lack in comparison to the introduced
custom link format.

#+begin_src emacs-lisp
(use-package zetteldeft
  :straight t
  ;; :bind (:map fpi-map (("d d" . deft)
  ;;                      ("d D" . zetteldeft-deft-new-search)
  ;;                      ("d R" . deft-refresh)
  ;;                      ("d s" . zetteldeft-search-at-point)
  ;;                      ("d c" . zetteldeft-search-current-id)
  ;;                      ("d f" . zetteldeft-follow-link)
  ;;                      ("d F" . zetteldeft-avy-file-search-ace-window)
  ;;                      ("d l" . zetteldeft-avy-link-search)
  ;;                      ("d t" . zetteldeft-avy-tag-search)
  ;;                      ("d T" . zetteldeft-tag-buffer)
  ;;                      ("d i" . zetteldeft-find-file-id-insert)
  ;;                      ("d I" . zetteldeft-find-file-full-title-insert)
  ;;                      ("d o" . zetteldeft-find-file)
  ;;                      ("d n" . zetteldeft-new-file)
  ;;                      ("d N" . zetteldeft-new-file-and-link)
  ;;                      ("d r" . zetteldeft-file-rename)
  ;;                      ("d x" . zetteldeft-count-words)))
  )
#+end_src
#+begin_src emacs-lisp :noweb-ref fpi-bindings :tangle no
(fpi/define-key fpi-map "dd" #'deft "Deft")
#+end_src

** Shell
#+begin_src emacs-lisp
(use-package shell
  :commands (shell shell-command))
#+end_src
To open and hide a shell quickly I use =shell-pop=.
#+begin_src emacs-lisp
(use-package shell-pop
  :straight t
  :bind (("C->" . shell-pop))
  :custom
  (shell-pop-shell-type (quote ("eshell" "*eshell*" (lambda nil (eshell))))))
#+end_src
Vterm is the emacs terminal emulator, which is closest to standard terminal emulators.
#+begin_src emacs-lisp
(use-package vterm
  :straight t)
#+end_src
** Grep
#+begin_src emacs-lisp
(use-package grep
  :custom (grep-command "grep --color -nH --null "))
#+end_src
** Proced
Built-in process monitor.
#+BEGIN_SRC emacs-lisp
(use-package proced
  :commands proced
  :custom
  (proced-toggle-auto-update t)
  (proced-auto-update-interval 1)
  (proced-descend t)
  (proced-filter 'user))
#+END_SRC
** Passwords
*** [[info:auth#Top][auth-source]]
#+begin_src emacs-lisp
(use-package auth-source
  :custom (auth-source-save-behavior nil))
#+end_src
*** Pass
Emacs interface & mode for the password manager [[https://www.passwordstore.org/][pass/password-store]].
The emacs =pass= package provides a nice buffer listing all stored
passwords files and also a good mode to edit them. The
=password-store= package provides functions to copy and edit
individual password files. I'm not sure which one I'll end up using. I
bind a small function to copy a password or a field if called with a
prefix to my custom keymap.
#+BEGIN_SRC emacs-lisp
(use-package pass
  :straight t)
#+END_SRC
#+begin_src emacs-lisp
(use-package password-store
  :straight t
  :commands (password-store-copy
             password-store-edit
             password-store-insert)
  :custom (password-store-time-before-clipboard-restore 30)
  :config (defun fpi/password-store-copy-pass-or-field (&optional arg)
            (interactive "P")
            (if arg
                (call-interactively 'password-store-copy-field)
              (call-interactively 'password-store-copy))))
#+end_src

#+begin_src emacs-lisp :noweb-ref fpi-bindings :tangle no
(fpi/define-key fpi-map "p" #'fpi/password-store-copy-pass-or-field "Pass")
#+end_src
**** auth-password-store/auth-source-pass
A password-store backend for the Emacs [[info:auth#Top][auth-source]] library which
normally uses the =~/.authinfo= file. For correct setup of
password-store files see [[https://rkm.id.au/2015/07/07/integrating-password-store-with-emacs/#fnr.1][here]] and in its [[https://github.com/DamienCassou/auth-password-store][github repo]]. For remote hosts
they need to contain the host and user info. The port is most of the
time inferred. The filename must also include the hostname. For
multiple users on the same host either use =user1@host.gpg= and
=user2@host.gpg= or =host/user1.gpg=, =host/user2.gpg=.
#+CAPTION: Example =pass= entry for use with =auth-source-pass=
#+begin_src pass-view
<password>
host: localhost
user: root
#+end_src

#+BEGIN_SRC emacs-lisp
(use-package auth-source-pass
  :straight t
  :config (auth-source-pass-enable))
#+END_SRC
** Ledger
Here is a good [[https://www.reddit.com/r/emacs/comments/8x4xtt][reddit thread]] about using ledger
#+BEGIN_SRC emacs-lisp
(use-package ledger-mode
  :straight t
  :init (setq ledger-clear-whole-transactions 1)
  :mode "\\.dat\\'"
  "\\.ledger\\'")
;; (use-package flycheck-ledger
;;   :straight t
;;   :after ledger-mode)
#+END_SRC

I also use some =org-capture= templates to quickly capture
transactions. They are defined in [[file:emacs-private.el.gpg::4][emacs-private.el.gpg]].

** Plotting data

=gnuplot= is a great option for plotting any kind of data, no matter
where it comes from.

#+begin_src emacs-lisp
(use-package gnuplot
  :straight t)
(use-package gnuplot-mode
  :straight t)
#+end_src
** HTML renderer
=shr= is the /Simple HTML renderer/ library, which Emacs uses to
display HTML. It is used by elfeed, notmuch and a variety of other
tools.

- Open links in =eww= instead of the system browser
- Limit the entry width to the same as =fill-column=
- Limit the size of images

#+BEGIN_SRC emacs-lisp
   ;; (lambda (url &rest args)
   ;;   (if args
   ;;          (browse-url-default-browser url)
   ;;     (eww-browse-url url)))

(use-package shr
  :commands (eww eww-browse-url)
  :custom
  (browse-url-browser-function 'eww-browse-url)
  (browse-url-generic-program "firefox")
  (shr-external-browser 'browse-url-generic)
  (shr-width 900)
  (shr-max-image-proportion 0.4)
  (shr-use-colors nil)
  (shr-use-fonts nil) )
#+END_SRC

Support for HTML code blocks with proper syntax highlighting. See [[https://github.com/xuchunyang/shr-tag-pre-highlight.el][its GitHub project page]].
#+BEGIN_SRC emacs-lisp
(use-package shr-tag-pre-highlight
  :straight t
  :after shr
  :config
  (add-to-list 'shr-external-rendering-functions
               '(pre . shr-tag-pre-highlight))
  (when (version< emacs-version "26")
    (with-eval-after-load 'eww
      (advice-add 'eww-display-html :around
                  'eww-display-html--override-shr-external-rendering-functions))))
#+END_SRC
** Email
For the setup of external mail specific programs see [[file:mail.org]].
*** Sending mail
I use =msmtp= to send mail.

- Infer the =envelope-from= header and therefore the adress to send
  the mail from based on the /From/ header argument.
- Add a =-f username= flag to the sendmail command line call, as msmtp
  needs it.
- Enable footnote-mode when entering message-mode.

#+begin_src emacs-lisp
(use-package message
  :custom
  (message-send-mail-function 'message-send-mail-with-sendmail)
  (message-sendmail-envelope-from 'header)
  (message-sendmail-f-is-evil nil)
  (message-kill-buffer-on-exit t)
  (message-forward-as-mime t)
  (message-fill-column nil) ;; to disable auto-fill-mode
  :hook (message-mode . footnote-mode))
(use-package sendmail
  :custom
  (send-mail-function 'smtpmail-send-it)
  (sendmail-program "/usr/bin/msmtp")
  (mail-specify-envelope-from t)
  (mail-envelope-from 'header))
#+end_src
*** MIME
#+begin_src emacs-lisp
(use-package mm-decode
  :config
  (use-package spice-mode
    :straight t
    :config
    (add-to-list 'auto-mode-alist '("\\.cir$" . spice-mode))
    (add-to-list 'auto-mode-alist '("\\.scs$" . spice-mode)))
  (defun mm-display-spice-inline (handle)
  "Show an spice mode text from HANDLE inline."
  (mm-display-inline-fontify handle 'spice-mode))
  (add-to-list 'mm-inline-media-tests '("application/x-wine-extension-cir" mm-display-spice-inline identity))
  (add-to-list 'mm-inlined-types "application/x-wine-extension-cir"))
#+end_src
**** S/MIME
Mail signing and encrypting with S/MIME needs a =gpgsm= setup and =smime.el=.

One can either use =EasyPG= or =OpenSSL= as external implementations. Still need to document these settings and packages better..
#+begin_src emacs-lisp
(use-package epg
  :custom (epg-pinentry-mode nil))
(use-package mml-sec
  :custom
  (mml-default-encrypt-method "smime")
  (mml-default-sign-method "smime")
  (mml-secure-cache-passphrase nil)
  (mml-secure-passphrase-cache-expiry 16)
  )
(use-package mml-smime
  :custom
  (mml-smime-use 'epg)
  (mml-secure-smime-sign-with-sender t)
)
#+end_src

#+begin_src emacs-lisp :tangle no
(use-package smime
  :custom
  (smime-CA-directory "~/certs/trusted")
  (smime-certificate-directory "~/certs")
  (smime-keys private/smime-keys)
  )
#+end_src

#+begin_src emacs-lisp :tangle no
(setq mm-sign-option 'guided)
#+end_src
*** MUA/Notmuch

After using =mu4e= as my mail user agent for a while I switched to
=notmuch=. I like the tagging based approach and the easy & great
searching.

- Show newest messages first.
- Set archive tags to remove/set upon archiving a mail with =a=.
- Setup some saved searched.
- Set my signature (defined in [[file:emacs-private.el.gpg::13][emacs-private.el.gpg]]).
- Set the FCC directories where sent mails should be saved to (also
  defined in [[file:emacs-private.el.gpg::20][emacs-private.el.gpg]].).
- Setup format=flowed
#+BEGIN_SRC emacs-lisp
(use-package notmuch
  :straight t
  :custom
  (notmuch-search-oldest-first nil)
  (notmuch-archive-tags '("-inbox" "-td" "+archived"))
  (notmuch-saved-searches
   '((:name "inbox" :query "tag:inbox" :key "i")
     (:name "unread (inb)" :query "(tag:unread and tag:inbox) or tag:td" :key "u")
     (:name "unread (tot)" :query "tag:unread and date:6month..0month" :key "U")
     (:name "flagged" :query "tag:flagged" :key "f")
     (:name "sent" :query "tag:sent" :key "s")
     (:name "drafts" :query "tag:draft" :key "d")
     (:name "all mail" :query "*" :key "a")
     (:name "tr" :query "tag:tr and date:6month..0month" :key "t")))
  (message-signature private/message-signature)
  (notmuch-fcc-dirs private/notmuch-fcc-dirs))
#+END_SRC
**** f=f
Hard new lines are identified using a ~hard~ text property and
displayed as =âŽ=. We need to make sure all newlines inserted by
message initialization (signature, ...) also have this text property.
For now I use this bad code.
#+BEGIN_SRC emacs-lisp :tangle no
(use-package messages-are-flowing
  :straight t
  :config (add-hook 'message-mode-hook 'messages-are-flowing-use-and-mark-hard-newlines))
(defun message-insert-signature (&optional force)
  (interactive)
  (goto-char (point-max))
  (let ((point (point)))
    (message-insert-signature-original force)
    (goto-char point)
    (while (search-forward "\n" nil t)
      (set-hard-newline-properties (- (point) 1) (point)))))

(defun message-insert-signature-original (&optional force)
  "Insert a signature.  See documentation for variable `message-signature'. "
  (interactive (list 0))
  (let* ((signature
          (cond
           ((and (null message-signature)
                 (eq force 0))
            (save-excursion
              (goto-char (point-max))
              (not (re-search-backward message-signature-separator nil t))))
           ((and (null message-signature)
                 force)
            t)
           ((functionp message-signature)
            (funcall message-signature))
           ((listp message-signature)
            (eval message-signature))
           (t message-signature)))
         signature-file)
    (setq signature
          (cond ((stringp signature)
                 signature)
                ((and (eq t signature) message-signature-file)
                 (setq signature-file
                       (if (and message-signature-directory
                                ;; don't actually use the signature directory
                                ;; if message-signature-file contains a path.
                                (not (file-name-directory
                                      message-signature-file)))
                           (expand-file-name message-signature-file
                                             message-signature-directory)
                         message-signature-file))
                 (file-exists-p signature-file))))
    (when signature
      (goto-char (point-max))
      ;; Insert the signature.
      (unless (bolp)
        (newline))
      (when message-signature-insert-empty-line
        (newline))
      (insert "-- ")
      (newline)
      (if (eq signature t)
          (insert-file-contents signature-file)
        (insert signature))
      (goto-char (point-max))
      (or (bolp) (newline)))))
#+END_SRC
*** Gnus
The customization for gnus is located in [[file:gnus.org][gnus.org]] and loaded from there upon startup.

I change the group buffer to something more memorable. This needs to be set before gnus is started and therefore only setting it in gnus.org is not sufficient.
#+begin_src emacs-lisp
(setq gnus-group-buffer "*Gnus*")
#+end_src
** Footnote Mode
#+begin_src emacs-lisp
(use-package footnote
  :custom
  (footnote-section-tag ""))
#+end_src
** BBDB
:PROPERTIES:
:ID:       390b66e5-b123-4cb1-9a56-61e41d7a818a
:END:
#+begin_src emacs-lisp
(use-package bbdb
  :straight t)
(bbdb-initialize 'gnus 'message)
(bbdb-mua-auto-update-init 'gnus 'message)

(setq bbdb-mua-pop-up 'horiz)
(setq bbdb-pop-up-layout 'one-line)
;; size of the bbdb popup
(setq bbdb-pop-up-window-size 0.15)
(setq bbdb-mua-pop-up-window-size 0.15)

;; What do we do when invoking bbdb interactively
(setq bbdb-mua-update-interactive-p '(query . create))

;; Make sure we look at every address in a message and not only the
;; first one
(setq bbdb-message-all-addresses t)

;; use ; on a message to invoke bbdb interactively
(add-hook
 'gnus-summary-mode-hook
 (lambda ()
    (define-key gnus-summary-mode-map (kbd ";") 'bbdb-mua-edit-field)))
#+end_src
To synchronize the database across devices I symlink it to my central synchronization directory:
#+begin_src shell :noweb-ref symlinks :tangle no
ln -siv ~/sync/bbdb/bbdb ~/.emacs.d/bbdb
#+end_src
** Compile
Fix ansi colors in compile buffers. From [[https://endlessparentheses.com/ansi-colors-in-the-compilation-buffer-output.html][endlessparentheses]].
#+begin_src emacs-lisp
(use-package compile
  :custom
  (compilation-scroll-output t)
  :config
  (require 'ansi-color)
  (defun endless/colorize-compilation ()
    "Colorize from `compilation-filter-start' to `point'."
    (let ((inhibit-read-only t))
      (ansi-color-apply-on-region
     compilation-filter-start (point))))
  :hook (compilation-filter . endless/colorize-compilation))
#+END_src
** Speed reading
=spray= offers an interface similar to the [[https://ds300.github.io/jetzt/][jetzt]] browser based speed reader.
#+begin_src emacs-lisp
(use-package spray
  :straight (:host nil :repo "https://git.sr.ht/~iank/spray/"))
#+end_src
** Context aware hydra
:PROPERTIES:
:ID:       22750e48-aaee-4f60-bdce-1d511ebe3375
:END:
[[https://dfeich.github.io/www/org-mode/emacs/2018/05/10/context-hydra.html][dfeich]] has a nice post on this. Basically it launches a specific hydra
based on the current mode and context around point.
#+BEGIN_SRC emacs-lisp
(defun dfeich/context-hydra-launcher ()
  "A launcher for hydras based on the current context."
  (interactive)
  (cl-case major-mode
    ((org-mode org-journal-mode)
     (let* ((elem (org-element-context))
            (etype (car elem))
            (type (org-element-property :type elem)))
       (cl-case etype
         (headline (fpi/org-edna-hydra/body))
         (src-block (hydra-babel-helper/body))
         (link (hydra-org-link-helper/body))
         ((table-row table-cell) (hydra-org-table-helper/body) )
         (t (message "No specific hydra for %s/%s" etype type)
            (hydra-org-default/body)))))
    ('bibtex-mode (org-ref-bibtex-hydra/body))
    ('ibuffer-mode (hydra-ibuffer-main/body))
    (t (message "No hydra for this major mode: %s" major-mode))))

;;; *** org mode hydras
(defhydra hydra-org-default (:color pink :hint nil)
  "
Org default hydra

_l_ insert template from last src block
_s_ insert src block ref with helm

_q_ quit
"
  ("l" fpi/copy-last-src-block-head :color blue)
  ("s" helm-lib-babel-insert :color blue)
  ("q" nil :color blue))


(defhydra hydra-org-link-helper (:color pink :hint nil)
  "
org link helper
_b_ backward slurp     _f_ forward slurp    _n_ next link
_m_ backward barf      _g_ forward barf     _p_ previous link
_t_ terminal at path

_q_ quit
"
  ("b" org-link-edit-backward-slurp)
  ("f" org-link-edit-forward-slurp)
  ("m" org-link-edit-backward-barf)
  ("g" org-link-edit-forward-barf)
  ("n" org-next-link)
  ("p" org-previous-link)
  ("t" fpi/gnome-terminal-at-link :color blue)
  ("q" nil :color blue))

(defhydra hydra-org-table-helper (:color pink :hint nil)
  "
org table helper
_r_ recalculate     _w_ wrap region      _c_ toggle coordinates
_i_ iterate table   _t_ transpose        _D_ toggle debugger
_B_ iterate buffer  _E_ export table     _d_ edit field
_e_ eval formula    _s_ sort lines

_q_ quit
"
  ("E" org-table-export :color blue)
  ("s" org-table-sort-lines)
  ("d" org-table-edit-field)
  ("e" org-table-eval-formula)
  ("r" org-table-recalculate)
  ("i" org-table-iterate)
  ("B" org-table-iterate-buffer-tables)
  ("w" org-table-wrap-region)
  ("D" org-table-toggle-formula-debugger)
  ("t" org-table-transpose-table-at-point)
  ("c" org-table-toggle-coordinate-overlays :color blue)
  ("q" nil :color blue))

(defun fpi/org-babel-src-mode-hydra ()
  "Launch a hydra specific to the src language of the current
  babel code block if defined."
  (interactive)
  (let* ((elem (org-element-context))
         (lang (plist-get (cadr elem) :language)))
    (pcase lang
      ("bibtex" (org-ref-bibtex-hydra/body)))))
(defhydra hydra-babel-helper (:color pink :hint nil)
  "
org babel src block helper functions
_n_ next       _i_ info           _I_ insert header
_p_ prev       _c_ check          _m_ ode hydra
_h_ goto head  _E_ expand
^ ^            _s_ split
_q_ quit       _r_ remove result  _e_ examplify region

"
  ("i" org-babel-view-src-block-info)
  ("I" org-babel-insert-header-arg)
  ("c" org-babel-check-src-block :color blue)
  ("s" org-babel-demarcate-block :color blue)
  ("n" org-babel-next-src-block)
  ("p" org-babel-previous-src-block)
  ("E" org-babel-expand-src-block :color blue)
  ("e" org-babel-examplify-region :color blue)
  ("r" org-babel-remove-result :color blue)
  ("h" org-babel-goto-src-block-head)
  ("m" fpi/org-babel-src-mode-hydra :color blue)
  ("q" nil :color blue))


;;; *** ibuffer hydra
;; from https://github.com/abo-abo/hydra/wiki/Ibuffer
(defhydra hydra-ibuffer-main (:color pink :hint nil)
  "
 ^Navigation^ | ^Mark^        | ^Actions^        | ^View^
-^----------^-+-^----^--------+-^-------^--------+-^----^-------
  _p_:    ÊŒ   | _m_: mark     | _D_: delete      | _g_: refresh
 _RET_: visit | _u_: unmark   | _S_: save        | _s_: sort
  _n_:    v   | _*_: specific | _a_: all actions | _/_: filter
-^----------^-+-^----^--------+-^-------^--------+-^----^-------
"
  ("n" ibuffer-forward-line)
  ("RET" ibuffer-visit-buffer :color blue)
  ("p" ibuffer-backward-line)

  ("m" ibuffer-mark-forward)
  ("u" ibuffer-unmark-forward)
  ("*" hydra-ibuffer-mark/body :color blue)

  ("D" ibuffer-do-delete)
  ("S" ibuffer-do-save)
  ("a" hydra-ibuffer-action/body :color blue)

  ("g" ibuffer-update)
  ("s" hydra-ibuffer-sort/body :color blue)
  ("/" hydra-ibuffer-filter/body :color blue)

  ("o" ibuffer-visit-buffer-other-window "other window" :color blue)
  ("q" nil "quit" :color blue))

(defhydra hydra-ibuffer-mark (:color teal :columns 5
                                     :after-exit (hydra-ibuffer-main/body))
  "Mark"
  ("*" ibuffer-unmark-all "unmark all")
  ("M" ibuffer-mark-by-mode "mode")
  ("m" ibuffer-mark-modified-buffers "modified")
  ("u" ibuffer-mark-unsaved-buffers "unsaved")
  ("s" ibuffer-mark-special-buffers "special")
  ("r" ibuffer-mark-read-only-buffers "read-only")
  ("/" ibuffer-mark-dired-buffers "dired")
  ("e" ibuffer-mark-dissociated-buffers "dissociated")
  ("h" ibuffer-mark-help-buffers "help")
  ("z" ibuffer-mark-compressed-file-buffers "compressed")
  ("b" hydra-ibuffer-main/body "back" :color blue))

(defhydra hydra-ibuffer-action (:color teal :columns 4
                                       :after-exit
                                       (if (eq major-mode 'ibuffer-mode)
                                           (hydra-ibuffer-main/body)))
  "Action"
  ("A" ibuffer-do-view "view")
  ("E" ibuffer-do-eval "eval")
  ("F" ibuffer-do-shell-command-file "shell-command-file")
  ("I" ibuffer-do-query-replace-regexp "query-replace-regexp")
  ("H" ibuffer-do-view-other-frame "view-other-frame")
  ("N" ibuffer-do-shell-command-pipe-replace "shell-cmd-pipe-replace")
  ("M" ibuffer-do-toggle-modified "toggle-modified")
  ("O" ibuffer-do-occur "occur")
  ("P" ibuffer-do-print "print")
  ("Q" ibuffer-do-query-replace "query-replace")
  ("R" ibuffer-do-rename-uniquely "rename-uniquely")
  ("T" ibuffer-do-toggle-read-only "toggle-read-only")
  ("U" ibuffer-do-replace-regexp "replace-regexp")
  ("V" ibuffer-do-revert "revert")
  ("W" ibuffer-do-view-and-eval "view-and-eval")
  ("X" ibuffer-do-shell-command-pipe "shell-command-pipe")
  ("b" nil "back"))

(defhydra hydra-ibuffer-sort (:color amaranth :columns 3)
  "Sort"
  ("i" ibuffer-invert-sorting "invert")
  ("a" ibuffer-do-sort-by-alphabetic "alphabetic")
  ("v" ibuffer-do-sort-by-recency "recently used")
  ("s" ibuffer-do-sort-by-size "size")
  ("f" ibuffer-do-sort-by-filename/process "filename")
  ("m" ibuffer-do-sort-by-major-mode "mode")
  ("b" hydra-ibuffer-main/body "back" :color blue))

(defhydra hydra-ibuffer-filter (:color amaranth :columns 4)
  "Filter"
  ("m" ibuffer-filter-by-used-mode "mode")
  ("M" ibuffer-filter-by-derived-mode "derived mode")
  ("n" ibuffer-filter-by-name "name")
  ("c" ibuffer-filter-by-content "content")
  ("e" ibuffer-filter-by-predicate "predicate")
  ("f" ibuffer-filter-by-filename "filename")
  (">" ibuffer-filter-by-size-gt "size")
  ("<" ibuffer-filter-by-size-lt "size")
  ("/" ibuffer-filter-disable "disable")
  ("b" hydra-ibuffer-main/body "back" :color blue))
#+END_SRC
** SSH tunnels
#+begin_src emacs-lisp
(use-package ssh-tunnels
  :straight t
  :custom (ssh-tunnels-configurations
           (cons `(:name "nntp"
                         :local-port 4321
                         :remote-port 4321
                         :login ,private/ssh-login-nntp
                         :host "localhost")
                 private/ssh-tunnels))
  :config (auto-ssh-tunnels-mode 1))
#+end_src
** Minor utilities
*** Screenshots / -casts
[[https://gitlab.com/ambrevar/emacs-gif-screencast][Here]] is a guide to creating emacs gif screencasts.

If compiled with =cairo= support emacs can directly create svg screenshots ([[https://www.reddit.com/r/emacs/comments/idz35e/emacs_27_can_take_svg_screenshots_of_itself/][source]]).
#+begin_src emacs-lisp
(defun screenshot-svg ()
  "Save a screenshot of the current frame as an SVG image.
Saves to a temp file and puts the filename in the kill ring."
  (interactive)
  (let* ((filename (make-temp-file "Emacs-" nil ".svg"))
         (data (x-export-frames nil 'svg)))
    (with-temp-file filename
      (insert data))
    (kill-new filename)
    (message filename)))
#+end_src
*** Whole-line-or-region
#+begin_src emacs-lisp
(use-package whole-line-or-region
  :straight t
  :config
  (whole-line-or-region-global-mode 1)
  (delight 'whole-line-or-region-local-mode nil t))
#+end_src
*** Pomodoro / Redtick
#+begin_src emacs-lisp
(use-package redtick
  :straight (:host github :repo "fpiper/redtick"
                   :branch "dev")
  :custom
  ((redtick-sound-volume "20")
   (redtick-play-sound t)
   (redtick-work-interval (* 60 20))
   (redtick-rest-interval (* 60 5)))
  :config (redtick-mode 1))
#+end_src
*** Script creation
Automatically make scripts executable upon save if first line is a shebang:
#+begin_src emacs-lisp
(add-hook 'after-save-hook
          'executable-make-buffer-file-executable-if-script-p)
#+end_src

The =Auto-Insert= package helps inserting header templates upon creating files.
#+begin_src emacs-lisp
(use-package autoinsert
  :config
    (define-auto-insert '("\\.sh\\'" . "Shell script skeleton")
    '(""
      "#!/usr/bin/env bash" \n \n))
    (auto-insert-mode 1))
#+end_src
* Language settings
End sentences with single spaces.
#+begin_src emacs-lisp
(setq sentence-end-double-space nil)
#+end_src
** Spellcheck
#+begin_src emacs-lisp
(use-package ispell
  :config
  (setq ispell-program-name "/usr/bin/hunspell")
  (setq ispell-dictionary "en_US,de_DE")
  (ispell-set-spellchecker-params)
  (ispell-hunspell-add-multi-dic "en_US,de_DE")
  )
#+end_src
*** Flyspell
Setup mainly from [[https://github.com/howardabrams/dot-files/blob/master/emacs.org][Howard Abrams]].
#+begin_src emacs-lisp
(use-package flyspell
  :delight
  :init
  (add-hook 'prog-mode-hook 'flyspell-prog-mode)
  (dolist (hook '(text-mode-hook org-mode-hook))
    (add-hook hook (lambda () (flyspell-mode 1))))
  (dolist (hook '(change-log-mode-hook log-edit-mode-hook org-agenda-mode-hook))
    (add-hook hook (lambda () (flyspell-mode -1)))))
#+end_src
* Interface
** General
#+begin_src emacs-lisp
(use-package emacs
  :custom
  (vc-follow-symlinks t)
  (echo-keystrokes 0.25)
  (auto-revert-verbose nil)
  :config
  (defalias 'yes-or-no-p 'y-or-n-p)
  (put 'dired-find-alternate-file 'disabled nil)
  (put 'narrow-to-region 'disabled nil))
#+end_src
** Rainbow mode
#+begin_src emacs-lisp
(use-package rainbow-mode
  :straight t)
#+end_src
** Parentheses
#+begin_src emacs-lisp
(use-package paren
  :custom
  (show-paren-style 'mixed)
  (show-paren-when-point-in-periphery t)
  (show-paren-when-point-inside-paren t)
  :config
  (show-paren-mode 1))
#+end_src
** Whitespace
I do not really care about spaces versus tabs most of the time. I only
want it to be consistent within a file.
#+begin_src emacs-lisp
(use-package emacs
  :config
  (define-minor-mode tab-mode
    "Toggle tab and space based indentation."
    :init-value nil
    :lighter " Â»"
    (if tab-mode
        (progn
          (setq indent-tabs-mode t)
          (setq tab-width 4)
          )
      (setq indent-tabs-mode nil)
      (setq tab-width 8)
      ))
  (defun enable-tab-mode ()
    (tab-mode 1))
  (defun disable-tab-mode ()
    (tab-mode -1))
  :custom
  (indent-tabs-mode nil)
  ;; (tab-width 4)
  ;; (tab-mode 1)
  :hook
  (prog-mode . enable-tab-mode)
  (emacs-lisp-mode . disable-tab-mode)
  (lisp-mode . disable-tab-mode)
  (matlab-mode . enable-tab-mode)
  )
#+end_src
Instead of =$= use =âŽ= to indicate newlines
#+begin_src emacs-lisp
(use-package whitespace
  :delight
  :custom (whitespace-display-mappings '((space-mark 32
                                                     [183]
                                                     [46])
                                         (space-mark 160
                                                     [164]
                                                     [95])
                                         (newline-mark 10
                                                       [9166 10]) ;;[36 10]
                                         (tab-mark 9
                                                   [187 9]
                                                   [92 9]))))
#+end_src
** Notifications
#+begin_src emacs-lisp
(use-package sauron
  :straight t
  :custom
  (sauron-separate-frame (not (eq (fpi/current-device-info :wm) 'exwm)))
  (sauron-notifications-urgency-to-priority-plist '(:low 2 :normal 4 :critical 5 :otherwise 2))
  :config
  (add-to-list 'sauron-modules 'sauron-dbus))
(use-package alert
  :straight t)
(use-package org-alert
  :straight t)
#+end_src
** Undo

Emacs undo mechanic can be confusing. =undo-tree= is a great package
but is prone to corruption and also does not allow undo based on the
active region.

*** Vundo
=Vundo= is a promising alternative to =undo-tree=, that is compatible with the default emacs undo/redo system. Its function is described in detail in [[https://archive.casouri.cat/note/2021/visual-undo-tree/index.html][this blogpost]].
#+begin_src emacs-lisp
(use-package vundo
  :straight (:host github :repo "casouri/vundo"
                   :branch "master")
  :bind (("M-_" . vundo)))
#+end_src
*** Undo-propose                                                  :ARCHIVE:
=undo-propose= shows undo changes in a temporary buffer. For the
keybindings see [[elisp:(which-key-show-full-keymap
'undo-propose-mode-map)]]. =undo-propose-commit= commits the cumulated
undo changes and the traveled undo history to the original buffer.
=undo-propose-squash-commit= omits the history.

The temporary buffer messes up point and folding in org buffers.
Therefore I don't use it anymore and should someday look into how this
temporary buffer is created.

#+begin_src emacs-lisp :tangle no
(use-package undo-propose
  :straight t
  :bind (("C-/" . undo-propose)))
#+end_src
** Electric stuff
#+begin_src emacs-lisp
(use-package electric
  :init
  (setq electric-pair-inhibit-predicate 'electric-pair-conservative-inhibit)
  (setq electric-pair-pairs '((?\" . ?\")
                              (?â€˜ . ?â€™)
                              (?â€œ . ?â€)
                              (?Â« . ?Â»)
                              (?â€ž . ?â€œ)
                              (?â€š . ?â€˜)
                              ))
  (setq electric-pair-skip-self 'electric-pair-default-skip-self)
  (setq electric-quote-context-sensitive t)
  (setq electric-quote-paragraph t)
  (setq electric-quote-string nil)
  :config
  (electric-indent-mode 1)
  (electric-pair-mode 1)
  (electric-quote-mode -1))
#+end_src
** Writing Setup
:PROPERTIES:
:ID:       9746c4dd-52d9-47fa-943b-7aa58601f22b
:END:
I gather all settings related to writing in a minor mode.
#+begin_src emacs-lisp
(define-minor-mode prose-mode
  "Toggle some settings for text based buffers."
  :init-value nil
  :lighter " âœŽ"
  (if prose-mode
      (progn
        (olivetti-mode 1)
        (set-window-fringes (selected-window) 0 0)
        (variable-pitch-mode 1)
        )
    (olivetti-mode -1)
    (set-window-fringes (selected-window) nil)
    (variable-pitch-mode -1)
    ))
#+end_src
The mode is enabled for all =text-mode= based buffers by default.
#+begin_src emacs-lisp
(add-hook 'text-mode-hook 'prose-mode)
#+end_src
Also set an easy keybinding to toggle it manually.
#+begin_src emacs-lisp :noweb-ref fpi-bindings :tangle no
(fpi/define-key fpi/toggle-map "p" #'prose-mode "Prose")
#+end_src

Olivetti mode is used to center text in the buffer. This somehow helps with writing.
#+begin_src emacs-lisp
(use-package olivetti
  :straight t
  :delight
  :custom
  (olivetti-body-width 80)
  ;; (olivetti-minimum-body-width 70)
  )
#+end_src

For org-mode also reduce indentation by =org-indent-mode= as described [[https://explog.in/notes/writingsetup.html][here]].
#+begin_src emacs-lisp :noweb-ref org-indent-custom :tangle no
(org-indent-indentation-per-level 1)
#+end_src
These settings are also from the above blog post, but mainly manually set what =org-indent-mode= does anyway.
#+begin_src emacs-lisp :noweb-ref org-custom :tangle no
(org-adapt-indentation nil)
(org-hide-leading-stars t)
(org-hide-emphasis-markers t)
(org-cycle-separator-lines 1)
#+end_src

While I generally use ~fit-window-to-buffer~ (bound to =C-z s=) to fit a buffer to its content width (see [[id:99f1af26-1383-43c1-8408-9a13c495925e][Window configuration]]), buffers in =prose-mode= can reduced to ~olivetti-body-width~ if it is an integer.
#+begin_src emacs-lisp
(defun fpi/fit-window-to-buffer (&optional WINDOW MAX-HEIGHT MIN-HEIGHT MAX-WIDTH MIN-WIDTH PRESERVE-SIZE)
  "Wrapper around `fit-window-to-buffer' which considers `olivetti-mode'.

If `olivetti-body-width' is a number fit the window width to it instead of the actual line width."
  (interactive)
  (let ((max-width (when (and olivetti-mode (numberp olivetti-body-width))
                     (round (* 1.03 olivetti-body-width)))))
    (fit-window-to-buffer (selected-window) nil nil max-width nil)
    ))
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref fpi-bindings
(fpi/define-key 'fpi-map (kbd "s") 'fpi/fit-window-to-buffer "Size window to buffer")
#+end_src

* Wrapping up

Some stuff that is run after everything else.
#+begin_src emacs-lisp
<<theme-dependent-vars>>
<<themes>>
#+end_src
